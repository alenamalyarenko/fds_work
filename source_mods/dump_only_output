#ifndef GITHASH_PP
#define GITHASH_PP "unknown"
#endif

!> \brief Routines for handling output

MODULE DUMP

USE PRECISION_PARAMETERS
USE MESH_VARIABLES
USE GLOBAL_CONSTANTS
USE OUTPUT_CLOCKS
USE MESH_POINTERS
USE DEVICE_VARIABLES
USE CONTROL_VARIABLES
USE OUTPUT_DATA
USE COMPLEX_GEOMETRY, ONLY : WRITE_GEOM,WRITE_GEOM_ALL,CC_FGSC,CC_IDCF,CC_IDCC,CC_UNKZ,CC_UNKF,CC_FTYPE_RCGAS,&
                             CC_FTYPE_CFGAS,CC_FTYPE_CFINB,CC_SOLID,FCELL,CC_CGSC,CC_CUTCFE,TRIANGULATE,&
                             CC_VGSC,CC_GASPHASE,MAKE_UNIQUE_VERT_ARRAY,AVERAGE_FACE_VALUES

USE CC_SCALARS, ONLY : ADD_Q_DOT_CUTCELLS,GET_PRES_CFACE,GET_PRES_CFACE_TEST,GET_UVWGAS_CFACE,GET_MUDNS_CFACE
IMPLICIT NONE (TYPE,EXTERNAL)
PRIVATE

REAL(EB), POINTER, DIMENSION(:,:,:) :: WFX=>NULL(),WFY=>NULL(),WFZ=>NULL()
INTEGER :: N_DEVC_FILES
CHARACTER(80) :: TCFORM
LOGICAL :: EX,DRY,OPN,FROM_BNDF=.FALSE.

TYPE (MESH_TYPE), POINTER :: M=>NULL()
TYPE (LAGRANGIAN_PARTICLE_TYPE), POINTER :: LP=>NULL()
TYPE (OBSTRUCTION_TYPE), POINTER :: OB=>NULL()
TYPE (VENTS_TYPE), POINTER :: VT=>NULL()
TYPE (LAGRANGIAN_PARTICLE_CLASS_TYPE), POINTER :: LPC=>NULL()
TYPE (SPECIES_TYPE), POINTER :: SS=>NULL()
TYPE (REACTION_TYPE), POINTER :: RN=>NULL()
TYPE (SURFACE_TYPE),POINTER :: SF=>NULL()
TYPE (MATERIAL_TYPE),POINTER :: ML=>NULL()
TYPE (PROPERTY_TYPE), POINTER :: PY=>NULL()
TYPE (DEVICE_TYPE), POINTER :: DV=>NULL(), DV2=>NULL()
TYPE (SUBDEVICE_TYPE), POINTER :: SDV=>NULL()
TYPE (SLICE_TYPE), POINTER :: SL=>NULL()
TYPE (WALL_TYPE), POINTER :: WC=>NULL()
TYPE (THIN_WALL_TYPE), POINTER :: TW=>NULL()
TYPE (CFACE_TYPE), POINTER :: CFA=>NULL()
TYPE (BOUNDARY_FILE_TYPE), POINTER :: BF=>NULL()
TYPE (ISOSURFACE_FILE_TYPE), POINTER :: IS=>NULL()
TYPE (INITIALIZATION_TYPE), POINTER :: IN=>NULL()

PUBLIC ASSIGN_FILE_NAMES,INITIALIZE_GLOBAL_DUMPS,INITIALIZE_MESH_DUMPS,WRITE_STATUS_FILES, &
       TIMINGS,FLUSH_GLOBAL_BUFFERS,FLUSH_LOCAL_BUFFERS,READ_RESTART,WRITE_DIAGNOSTICS, &
       WRITE_SMOKEVIEW_FILE,DUMP_MESH_OUTPUTS,UPDATE_GLOBAL_OUTPUTS,DUMP_DEVICES,DUMP_HRR,DUMP_MASS,DUMP_CONTROLS,&
       INITIALIZE_DIAGNOSTIC_FILE,DUMP_RESTART,DUMP_HVAC,&
       DUMP_UVW,DUMP_GEOM,UPDATE_DEVICES_2,WRITE_DEVC_CTRL_LOG

CONTAINS

!!! AM 15092023 
!!! calls to other output subroutines
!!!



!> \brief Call the subroutines that update device, heat release, and mass output

SUBROUTINE UPDATE_GLOBAL_OUTPUTS(T,DT,NM)

 USE COMP_FUNCTIONS, ONLY : CURRENT_TIME
 REAL(EB) :: TNOW
 INTEGER, INTENT(IN) :: NM
 REAL(EB),INTENT(IN) :: T,DT
 
 TNOW = CURRENT_TIME()
 
 CALL UPDATE_HRR(DT,NM)
 CALL UPDATE_MASS(DT,NM)
 CALL UPDATE_DEVICES_1(T,DT,NM)
 
 T_USED(7) = T_USED(7) + CURRENT_TIME() - TNOW
END SUBROUTINE UPDATE_GLOBAL_OUTPUTS
 
 
!> \brief Call subroutines that output quantities associated with each mesh, like slice, boundary, and particle files

SUBROUTINE DUMP_MESH_OUTPUTS(T,DT,NM)
 
 USE COMP_FUNCTIONS, ONLY : CURRENT_TIME
 USE TURBULENCE, ONLY: SANDIA_OUT, SPECTRAL_OUTPUT
 REAL(EB) :: TNOW
 REAL(EB), INTENT(IN) :: T,DT
 INTEGER, INTENT(IN) :: NM
 CHARACTER(80) :: FN_UVW,FN_MMS,FN_SPECTRUM,FN_TMP,FN_SPEC
 
 TNOW = CURRENT_TIME()
 
 IF (T>=PART_CLOCK(PART_COUNTER(NM)) .AND. PARTICLE_FILE) THEN
    CALL DUMP_PART(T,NM)
    DO WHILE(PART_COUNTER(NM)<SIZE(PART_CLOCK)-1)
       PART_COUNTER(NM) = PART_COUNTER(NM) + 1
       IF (PART_CLOCK(PART_COUNTER(NM))>=T) EXIT
    ENDDO
 ENDIF
 
 IF (T>=ISOF_CLOCK(ISOF_COUNTER(NM))) THEN
    CALL DUMP_ISOF(T,DT,NM)
    DO WHILE(ISOF_COUNTER(NM)<SIZE(ISOF_CLOCK)-1)
       ISOF_COUNTER(NM) = ISOF_COUNTER(NM) + 1
       IF (ISOF_CLOCK(ISOF_COUNTER(NM))>=T) EXIT
    ENDDO
 ENDIF
 
 IF (T>=SM3D_CLOCK(SM3D_COUNTER(NM)) .AND. SMOKE3D) THEN
    CALL DUMP_SMOKE3D(T,DT,NM)
    DO WHILE(SM3D_COUNTER(NM)<SIZE(SM3D_CLOCK)-1)
       SM3D_COUNTER(NM) = SM3D_COUNTER(NM) + 1
       IF (SM3D_CLOCK(SM3D_COUNTER(NM))>=T) EXIT
    ENDDO
 ENDIF
 
 IF (T>=SLCF_CLOCK(SLCF_COUNTER(NM))) THEN
    CALL DUMP_SLCF(T,DT,NM,0)
    DO WHILE(SLCF_COUNTER(NM)<SIZE(SLCF_CLOCK)-1)
       SLCF_COUNTER(NM) = SLCF_COUNTER(NM) + 1
       IF (SLCF_CLOCK(SLCF_COUNTER(NM))>=T) EXIT
    ENDDO
 ENDIF
 
 IF (T>=SL3D_CLOCK(SL3D_COUNTER(NM)) .OR. STOP_STATUS==INSTABILITY_STOP) THEN
    CALL DUMP_SLCF(T,DT,NM,2)
    DO WHILE(SL3D_COUNTER(NM)<SIZE(SL3D_CLOCK)-1)
       SL3D_COUNTER(NM) = SL3D_COUNTER(NM) + 1
       IF (SL3D_CLOCK(SL3D_COUNTER(NM))>=T) EXIT
    ENDDO
 ENDIF
 
 IF (T>=BNDF_CLOCK(BNDF_COUNTER(NM))) THEN
    CALL DUMP_BNDF(T,DT,NM)
    DO WHILE(BNDF_COUNTER(NM)<SIZE(BNDF_CLOCK)-1)
       BNDF_COUNTER(NM) = BNDF_COUNTER(NM) + 1
       IF (BNDF_CLOCK(BNDF_COUNTER(NM))>=T) EXIT
    ENDDO
 ENDIF
 
 IF (T>=PL3D_CLOCK(PL3D_COUNTER(NM)) .OR. STOP_STATUS==INSTABILITY_STOP) THEN
    CALL DUMP_SLCF(T,DT,NM,1)
    DO WHILE(PL3D_COUNTER(NM)<SIZE(PL3D_CLOCK)-1)
       PL3D_COUNTER(NM) = PL3D_COUNTER(NM) + 1
       IF (PL3D_CLOCK(PL3D_COUNTER(NM))>=T) EXIT
    ENDDO
 ENDIF
 
 IF (T>=PROF_CLOCK(PROF_COUNTER(NM))) THEN
    CALL DUMP_PROF(T,NM)
    DO WHILE(PROF_COUNTER(NM)<SIZE(PROF_CLOCK)-1)
       PROF_COUNTER(NM) = PROF_COUNTER(NM) + 1
       IF (PROF_CLOCK(PROF_COUNTER(NM))>=T) EXIT
    ENDDO
 ENDIF
 
 IF (T>=UVW_CLOCK(UVW_COUNTER(NM))) THEN
    IF (PERIODIC_TEST==9) THEN
       WRITE(FN_SPECTRUM,'(A,A,I0,A)') TRIM(CHID),'_spec_',UVW_COUNTER(NM),'.csv'
       CALL DUMP_UVW(NM,FN_SPECTRUM)
    ELSE
       WRITE(FN_UVW,'(A,A,I0,A,I0,A)') TRIM(CHID),'_uvw_t',UVW_COUNTER(NM),'_m',NM,'.csv'
       CALL DUMP_UVW(NM,FN_UVW)
    ENDIF
    DO WHILE(UVW_COUNTER(NM)<SIZE(UVW_CLOCK)-1)
       UVW_COUNTER(NM) = UVW_COUNTER(NM) + 1
       IF (UVW_CLOCK(UVW_COUNTER(NM))>=T) EXIT
    ENDDO
 ENDIF
 
 IF (T>=TMP_CLOCK(TMP_COUNTER(NM))) THEN
    WRITE(FN_TMP,'(A,A,I0,A,I0,A)') TRIM(CHID),'_tmp_t',TMP_COUNTER(NM),'_m',NM,'.csv'
    CALL DUMP_TMP(NM,FN_TMP)
    DO WHILE(TMP_COUNTER(NM)<SIZE(TMP_CLOCK)-1)
       TMP_COUNTER(NM) = TMP_COUNTER(NM) + 1
       IF (TMP_CLOCK(TMP_COUNTER(NM))>=T) EXIT
    ENDDO
 ENDIF
 
 IF (T>=SPEC_CLOCK(SPEC_COUNTER(NM))) THEN
    WRITE(FN_SPEC,'(A,A,I0,A,I0,A)') TRIM(CHID),'_spec_t',SPEC_COUNTER(NM),'_m',NM,'.csv'
    CALL DUMP_SPEC(NM,FN_SPEC)
    DO WHILE(SPEC_COUNTER(NM)<SIZE(SPEC_CLOCK)-1)
       SPEC_COUNTER(NM) = SPEC_COUNTER(NM) + 1
       IF (SPEC_CLOCK(SPEC_COUNTER(NM))>=T) EXIT
    ENDDO
 ENDIF
 
 PERIODIC_TEST_SELECT: SELECT CASE(PERIODIC_TEST)
    CASE(7,11)
       IF (T>=MMS_TIMER .AND. NM==1) THEN
          WRITE(FN_MMS,'(A,A)') TRIM(CHID),'_mms.csv'
          CALL DUMP_MMS(NM,FN_MMS,T)
          MMS_TIMER=HUGE_EB
       ENDIF
    CASE(21,22,23)
       IF (T>=MMS_TIMER .AND. NM==1) THEN
          WRITE(FN_MMS,'(A,A)') TRIM(CHID),'_mms.csv'
          CALL DUMP_ROTCUBE_MMS(NM,FN_MMS,T)
          MMS_TIMER=HUGE_EB
       ENDIF
    CASE(9)
       IF (T>=TURB_INIT_CLOCK) THEN
          TURB_INIT_CLOCK=HUGE_EB ! only write ini_salsa.dat file once
          CALL SANDIA_OUT(NM)
       ENDIF
 END SELECT PERIODIC_TEST_SELECT
 
 T_USED(7) = T_USED(7) + CURRENT_TIME() - TNOW
END SUBROUTINE DUMP_MESH_OUTPUTS


!!! AM 15092023 
!!! file convention
!!!


!> \brief Assign names and logical units for all output files

SUBROUTINE ASSIGN_FILE_NAMES

 USE COMP_FUNCTIONS, ONLY: GET_FILE_NUMBER
 INTEGER :: NM,I,N
 CHARACTER(LABEL_LENGTH) :: CFORM
 
 ! Set up file number counter
 
 ALLOCATE(FILE_COUNTER(0:N_MPI_PROCESSES))
 FILE_COUNTER = 10
 
 ! GIT ID file
 
 FN_GIT = TRIM(CHID)//'_git.txt'
 
 ! Smokeview File
 
 FN_SMV = TRIM(CHID)//'.smv'
 LU_INFO  = GET_FILE_NUMBER()
 
 ! Diagnostic Output File
 
 FN_OUTPUT = TRIM(CHID)//'.out'
 IF (.NOT.OVERWRITE) THEN
    INQUIRE(FILE=FN_OUTPUT,EXIST=EX)
    IF (EX) THEN
       WRITE(LU_ERR,'(A,A,A)')  'ERROR: OVERWRITE=.FALSE. and the file ',TRIM(FN_OUTPUT),' exists.'
       STOP
    ENDIF
 ENDIF
 
 ! Runtime diagnostic CSV File
 
 LU_STEPS = GET_FILE_NUMBER()
 FN_STEPS = TRIM(CHID)//'_steps.csv'
 
 ! Mass and HRR Files
 
 IF (MASS_FILE) THEN
    LU_MASS  = GET_FILE_NUMBER()
    FN_MASS  = TRIM(CHID)//'_mass.csv'
 ENDIF
 
 LU_HRR = GET_FILE_NUMBER()
 FN_HRR = TRIM(CHID)//'_hrr.csv'
 
 ! HVAC output file
 
 LU_HVAC = GET_FILE_NUMBER()
 FN_HVAC = TRIM(CHID)//'.hvac'
 
 ! Device and Control Files
 
 IF (N_HISTOGRAM>0) THEN
    LU_HISTOGRAM=GET_FILE_NUMBER()
    FN_HISTOGRAM=TRIM(CHID)//'_hist.csv'
 ENDIF
 
 IF (COLUMN_DUMP_LIMIT) THEN
    N_DEVC_FILES = N_DEVC_TIME / DEVC_COLUMN_LIMIT
    IF (N_DEVC_FILES * DEVC_COLUMN_LIMIT < N_DEVC_TIME) N_DEVC_FILES = N_DEVC_FILES + 1
    N_CTRL_FILES = N_CTRL / CTRL_COLUMN_LIMIT
    IF (N_CTRL_FILES * CTRL_COLUMN_LIMIT < N_CTRL) N_CTRL_FILES = N_CTRL_FILES + 1
 ELSE
    IF (N_DEVC_TIME >= 1) THEN
       N_DEVC_FILES = 1
       DEVC_COLUMN_LIMIT = N_DEVC_TIME
    ENDIF
    IF (N_CTRL >= 1) THEN
       N_CTRL_FILES = 1
       CTRL_COLUMN_LIMIT = N_CTRL
    ENDIF
 ENDIF
 
 ALLOCATE(LU_DEVC(N_DEVC_FILES))
 ALLOCATE(FN_DEVC(N_DEVC_FILES))
 ALLOCATE(LU_CTRL(N_CTRL_FILES))
 ALLOCATE(FN_CTRL(N_CTRL_FILES))
 
 DO I=1,N_DEVC_FILES
    LU_DEVC(I) = GET_FILE_NUMBER()
    WRITE(FN_DEVC(I),'(A,A,I0,A)') TRIM(CHID),'_',I,'_devc.csv'
 ENDDO
 IF (N_DEVC_FILES==1) FN_DEVC(1) = TRIM(CHID)//'_devc.csv'
 
 DO I=1,N_CTRL_FILES
    LU_CTRL(I) = GET_FILE_NUMBER()
    WRITE(FN_CTRL(I),'(A,A,I0,A)') TRIM(CHID),'_',I,'_ctrl.csv'
 ENDDO
 IF (N_CTRL_FILES==1) FN_CTRL(1) = TRIM(CHID)//'_ctrl.csv'
 
 ! Line files
 
 IF (N_DEVC_LINE>0) THEN
    LU_LINE = GET_FILE_NUMBER()
    FN_LINE = TRIM(CHID)//'_line.csv'
 ENDIF
 
 ! Profile Files
 
 ALLOCATE(LU_PROF(N_PROF))
 ALLOCATE(FN_PROF(N_PROF))
 
 DO N=1,N_PROF
    LU_PROF(N) = GET_FILE_NUMBER()
    CFORM = '(A,A,I0,A)'
    WRITE(FN_PROF(N),CFORM) TRIM(CHID),'_prof_',N,'.csv'
 ENDDO
 
 ! Plot3D
 
 ALLOCATE(FN_XYZ(NMESHES))
 ALLOCATE(LU_XYZ(NMESHES))
 ALLOCATE(FN_PL3D(2*NMESHES))
 ALLOCATE(LU_PL3D(2*NMESHES))
 
 ALLOCATE(FN_ISOF(N_ISOF,NMESHES))
 ALLOCATE(LU_ISOF(N_ISOF,NMESHES))
 ALLOCATE(FN_ISOF2(N_ISOF,NMESHES))
 ALLOCATE(LU_ISOF2(N_ISOF,NMESHES))
 ALLOCATE(FN_SLCF(3*N_SLCF_MAX,NMESHES))
 ALLOCATE(LU_SLCF(3*N_SLCF_MAX,NMESHES))
 ALLOCATE(FN_SLCF_GEOM(N_SLCF_MAX,NMESHES))
 ALLOCATE(LU_SLCF_GEOM(N_SLCF_MAX,NMESHES))
 ALLOCATE(FN_GEOM(2)) ! later each geometry group may have a separate file
 ALLOCATE(LU_GEOM(2))
 ALLOCATE(FN_BNDF(2*N_BNDF,NMESHES))
 ALLOCATE(LU_BNDF(2*N_BNDF,NMESHES))
 IF (CC_IBM) THEN
    ALLOCATE(FN_CFACE_GEOM(NMESHES))
    ALLOCATE(LU_CFACE_GEOM(NMESHES))
    ALLOCATE(FN_BNDG(2*N_BNDF,NMESHES))
    ALLOCATE(LU_BNDG(2*N_BNDF,NMESHES))
 ENDIF
 IF (N_RADF>0) THEN
    ALLOCATE(FN_RADF(N_RADF,NMESHES))
    ALLOCATE(LU_RADF(N_RADF,NMESHES))
 ENDIF
 IF (TERRAIN_CASE) THEN
    ALLOCATE(FN_TERRAIN(NMESHES))
    ALLOCATE(LU_TERRAIN(NMESHES))
 ENDIF
 ALLOCATE(FN_SMOKE3D(N_SMOKE3D*3,NMESHES)) ! also allocate unit numbers and file names for the size files
 ALLOCATE(LU_SMOKE3D(N_SMOKE3D*3,NMESHES)) ! and the SMOKE3D_16 files (16 bit integers)
 ALLOCATE(FN_PART(2*NMESHES))
 ALLOCATE(LU_PART(2*NMESHES))
 ALLOCATE(FN_CORE(NMESHES))
 ALLOCATE(LU_CORE(NMESHES))
 ALLOCATE(FN_RESTART(NMESHES))
 ALLOCATE(LU_RESTART(NMESHES))
 
 MESH_LOOP: DO NM=1,NMESHES
 
    IF (PROCESS(NM)/=MY_RANK) CYCLE MESH_LOOP
 
    M => MESHES(NM)
 
    ! Plot3D Files
 
    LU_XYZ(NM)  = GET_FILE_NUMBER()
    LU_PL3D(NM) = GET_FILE_NUMBER()
    LU_PL3D(NM+NMESHES) = GET_FILE_NUMBER()
    WRITE(FN_XYZ(NM),'(A,A,I0,A)') TRIM(CHID),'_',NM,'.xyz'
 
    ! Iso Surface Files
 
    ! Allocate unit numbers and file names for isosurface files
    ! The unit numbers are intially negative so that the isosurface output
    ! routine "knows" when it is called the first time
 
    DO N=1,N_ISOF
       LU_ISOF(N,NM) = -GET_FILE_NUMBER()
       IF (RESTART) LU_ISOF(N,NM) = ABS(LU_ISOF(N,NM))
       LU_ISOF2(N,NM) = -GET_FILE_NUMBER()
       IF (RESTART) LU_ISOF2(N,NM) = ABS(LU_ISOF2(N,NM))
       WRITE(FN_ISOF(N,NM), '(A,A,I0,A,I0,A)') TRIM(CHID),'_',NM,'_',N,'.iso'
       WRITE(FN_ISOF2(N,NM),'(A,A,I0,A,I0,A)') TRIM(CHID),'_',NM,'_',N,'.viso'
    ENDDO
 
    ! Allocate unit numbers and file names for 3d smoke files
    ! The unit numbers are intially negative so that the 3d smoke output
    ! routine "knows" when it is called the first time
 
    DO N=1,N_SMOKE3D
       IF (SMOKE3D_FILE(N)%QUANTITY_INDEX==0) CYCLE
       LU_SMOKE3D(N,NM) = GET_FILE_NUMBER()
       WRITE(FN_SMOKE3D(N,NM),  '(A,A,I0,A,I0,A)') TRIM(CHID),'_',NM,'_',N,'.s3d'
       LU_SMOKE3D(N+N_SMOKE3D,NM) = GET_FILE_NUMBER()
       WRITE(FN_SMOKE3D(N+N_SMOKE3D,NM),'(A,A,I0,A,I0,A)') TRIM(CHID),'_',NM,'_',N,'.s3d.sz'
       LU_SMOKE3D(N+2*N_SMOKE3D,NM) = GET_FILE_NUMBER()
       WRITE(FN_SMOKE3D(N+2*N_SMOKE3D,NM),  '(A,A,I0,A,I0,A)') TRIM(CHID),'_',NM,'_',N,'.s16'
    ENDDO
 
    ! Slice Files
 
    DO N=1,M%N_SLCF
       LU_SLCF(N,NM)              = GET_FILE_NUMBER() ! slice file
       LU_SLCF_GEOM(N,NM)         = GET_FILE_NUMBER()
       LU_SLCF(N+N_SLCF_MAX,NM)   = GET_FILE_NUMBER() ! bounds for slice file
       LU_SLCF(N+2*N_SLCF_MAX,NM) = GET_FILE_NUMBER() ! run length encoded slice file
       CFORM = '(A,A,I0,A,I0,A)'
       WRITE(FN_SLCF(N,NM),CFORM) TRIM(CHID),'_',NM,'_',N,'.sf'
       WRITE(FN_SLCF_GEOM(N,NM),CFORM) TRIM(CHID),'_',NM,'_',N,'.gsf'
       WRITE(FN_SLCF(N+N_SLCF_MAX,NM),CFORM) TRIM(CHID),'_',NM,'_',N,'.sf.bnd'
       WRITE(FN_SLCF(N+2*N_SLCF_MAX,NM),CFORM) TRIM(CHID),'_',NM,'_',N,'.sf.rle'
    ENDDO
 
    ! Radiation Files
 
    DO N=1,M%N_RADF
       LU_RADF(N,NM) = GET_FILE_NUMBER()
       CFORM = '(A,A,I0,A,I0,A)'
       WRITE(FN_RADF(N,NM),CFORM) TRIM(CHID),'_radf_',NM,'_',N,'.txt'
    ENDDO
 
    ! Boundary Files
 
    DO N=1,N_BNDF
       LU_BNDF(N,NM) = GET_FILE_NUMBER()
       LU_BNDF(N+N_BNDF,NM) = GET_FILE_NUMBER()
       IF (CC_IBM) THEN
          LU_BNDG(N,NM) = GET_FILE_NUMBER()
          LU_BNDG(N+N_BNDF,NM) = GET_FILE_NUMBER()
       ENDIF
       WRITE(FN_BNDF(N,NM),'(A,A,I0,A,I0,A)')        TRIM(CHID),'_',NM,'_',N,'.bf'
       WRITE(FN_BNDF(N+N_BNDF,NM),'(A,A,I0,A,I0,A)') TRIM(CHID),'_',NM,'_',N,'.bf.bnd'
       IF (CC_IBM) THEN
          WRITE(FN_BNDG(N,NM),'(A,A,I0,A,I0,A)') TRIM(CHID),'_',NM,'_',N,'.be'
          WRITE(FN_BNDG(N+N_BNDF,NM),'(A,A,I0,A,I0,A)') TRIM(CHID),'_',NM,'_',N,'.be.bnd'
       ENDIF
    ENDDO
 
    ! CFACE file for mesh NM:
 
    IF (CC_IBM) THEN
       LU_CFACE_GEOM(NM) = GET_FILE_NUMBER()
       WRITE(FN_CFACE_GEOM(NM),'(A,A,I0,A)') TRIM(CHID),'_',NM,'.gcf'
    ENDIF
 
    ! Boundary Files mapped to slice files for terrain cases
 
    IF (TERRAIN_CASE) THEN
       LU_TERRAIN(NM) = GET_FILE_NUMBER()
       WRITE(FN_TERRAIN(NM),'(A,A,I0,A)') TRIM(CHID),'_',NM,'.ter'
    ENDIF
 
    ! Particle Files
 
    IF (PARTICLE_FILE) THEN
       LU_PART(NM) = GET_FILE_NUMBER()
       LU_PART(NM+NMESHES) = GET_FILE_NUMBER()
       WRITE(FN_PART(NM),'(A,I0,A)') TRIM(CHID)//'_',NM,'.prt5'
       WRITE(FN_PART(NM+NMESHES),'(A,I0,A)') TRIM(CHID)//'_',NM,'.prt5.bnd'
    ENDIF
 
    ! Restart Files
 
    LU_RESTART(NM) = GET_FILE_NUMBER()
    WRITE(FN_RESTART(NM),'(A,A,I0,A)') TRIM(RESTART_CHID),'_',NM,'.restart'
    LU_CORE(NM)    = GET_FILE_NUMBER()
    WRITE(FN_CORE(NM),   '(A,A,I0,A)') TRIM(CHID),'_',NM,'.restart'
 
 ENDDO MESH_LOOP
 
 ! Unstructured Geometry Files
 
 IF (N_FACE>0 .OR. N_GEOMETRY>0) THEN
    DO N=1,1
       LU_GEOM(N) = GET_FILE_NUMBER()
       WRITE(FN_GEOM(N),'(A,A,I0,A)') TRIM(CHID),'_',N,'.ge'
       LU_GEOM(N+1) = GET_FILE_NUMBER()   ! used to output which &GEOM a face belongs too
       WRITE(FN_GEOM(N+1),'(A,A,I0,A)') TRIM(CHID),'_',N,'.ge2'
    ENDDO
 ENDIF
 
 ! TGA output
 
 IF (TGA_SURF_INDEX>0) THEN
    LU_TGA = GET_FILE_NUMBER()
    WRITE(FN_TGA,'(A,A)') TRIM(CHID),'_tga.csv'
 ENDIF
 
 ! Status File
 
 IF (STATUS_FILES) THEN
    LU_NOTREADY = GET_FILE_NUMBER()
    FN_NOTREADY = TRIM(CHID)//'.notready'
 ENDIF
 
 IF (VELOCITY_ERROR_FILE) THEN
    LU_VELOCITY_ERROR = GET_FILE_NUMBER()
    FN_VELOCITY_ERROR = TRIM(CHID)//'_pressit.csv'
 ENDIF
 
 IF (CFL_FILE) THEN
    LU_CFL = GET_FILE_NUMBER()
    FN_CFL = TRIM(CHID)//'_cfl.csv'
 ENDIF
 
 IF (WRITE_DEVC_CTRL) THEN
    LU_DEVC_CTRL = GET_FILE_NUMBER()
    FN_DEVC_CTRL = TRIM(CHID)//'_devc_ctrl_log.csv'
 ENDIF

END SUBROUTINE ASSIGN_FILE_NAMES




!> \brief Open and write header info for output files associated with particular meshes, like slice, boundary, and particle

SUBROUTINE INITIALIZE_MESH_DUMPS(NM)

USE COMP_FUNCTIONS, ONLY: CURRENT_TIME
USE MEMORY_FUNCTIONS, ONLY: RE_ALLOCATE_STRINGS,CHKMEMERR
USE RADCONS, ONLY: DLX,DLY,DLZ
INTEGER, INTENT(IN) :: NM
INTEGER :: IOR,IZERO,I,J,K,N,I1B,I2B,IW,NN,NF,IP
INTEGER :: NTSL
LOGICAL, ALLOCATABLE, DIMENSION(:,:) :: PAINT_FACE
REAL(EB) :: TNOW,NRM
REAL(FB), ALLOCATABLE, DIMENSION(:,:) :: Z_TERRAIN
LOGICAL, ALLOCATABLE, DIMENSION(:,:) :: OUT_OF_MESH
CHARACTER(LEN=1024) :: SLICEPARMS, SLICELABEL
TYPE(PATCH_TYPE), POINTER :: PA
INTEGER :: CC_VAL,NSTEPS
INTEGER :: SMOKE3D_16_COMPRESS, SMOKE3D_16_VERSION
TYPE (BOUNDARY_COORD_TYPE), POINTER :: BC
TYPE (RAD_FILE_TYPE), POINTER :: RF
logical :: exist
TNOW=CURRENT_TIME()

M => MESHES(NM)

IBAR=>M%IBAR
JBAR=>M%JBAR
KBAR=>M%KBAR
IBP1=>M%IBP1
JBP1=>M%JBP1
KBP1=>M%KBP1

! Compute grid coords in single precision for output

ALLOCATE(M%XPLT(0:IBAR),STAT=IZERO)
CALL ChkMemErr('DUMP','XPLT',IZERO)
ALLOCATE(M%YPLT(0:JBAR),STAT=IZERO)
CALL ChkMemErr('DUMP','YPLT',IZERO)
ALLOCATE(M%ZPLT(0:KBAR),STAT=IZERO)
CALL ChkMemErr('DUMP','ZPLT',IZERO)

DO I=0,IBAR
   M%XPLT(I) = REAL(M%X(I),FB)
ENDDO
DO J=0,JBAR
   M%YPLT(J) = REAL(M%Y(J),FB)
ENDDO
DO K=0,KBAR
   M%ZPLT(K) = REAL(M%Z(K),FB)
ENDDO

! Initialize PLOT3D grid file (CHID.xyz)

ALLOCATE(M%IBLK(0:IBAR,0:JBAR,0:KBAR),STAT=IZERO)
CALL ChkMemErr('DUMP','IBLK',IZERO)
ALLOCATE(M%QQ(0:IBP1,0:JBP1,0:KBP1,5),STAT=IZERO)
CALL ChkMemErr('DUMP','QQ',IZERO)
ALLOCATE(M%QQ2(0:IBP1,0:JBP1,0:KBP1,1),STAT=IZERO)
CALL ChkMemErr('DUMP','QQ2',IZERO)
M%QQ=0._FB
M%QQ2=0._FB

WRITE_XYZ_FILE: IF (WRITE_XYZ) THEN
   OPEN(LU_XYZ(NM),FILE=FN_XYZ(NM),FORM='UNFORMATTED',STATUS='REPLACE')
   DO K=0,KBAR
      DO J=0,JBAR
         DO I=0,IBAR
            IF (M%CELL(M%CELL_INDEX(I,J,K))%SOLID    .AND. M%CELL(M%CELL_INDEX(I+1,J,K))%SOLID   .AND. &
                M%CELL(M%CELL_INDEX(I,J+1,K))%SOLID  .AND. M%CELL(M%CELL_INDEX(I,J,K+1))%SOLID   .AND. &
                M%CELL(M%CELL_INDEX(I+1,J+1,K))%SOLID.AND. M%CELL(M%CELL_INDEX(I+1,J,K+1))%SOLID .AND. &
                M%CELL(M%CELL_INDEX(I,J+1,K+1))%SOLID.AND. M%CELL(M%CELL_INDEX(I+1,J+1,K+1))%SOLID) THEN
               M%IBLK(I,J,K) = 0
            ELSE
               M%IBLK(I,J,K) = 1
            ENDIF
         ENDDO
      ENDDO
   ENDDO


   WRITE(LU_XYZ(NM)) IBP1,JBP1,KBP1
   WRITE(LU_XYZ(NM)) (((M%XPLT(I),I=0,IBAR),J=0,JBAR),K=0,KBAR),(((M%YPLT(J),I=0,IBAR),J=0,JBAR),K=0,KBAR), &
                     (((M%ZPLT(K),I=0,IBAR),J=0,JBAR),K=0,KBAR),(((M%IBLK(I,J,K),I=0,IBAR),J=0,JBAR),K=0,KBAR)
   CLOSE(LU_XYZ(NM))
   IF (M%N_STRINGS+2>M%N_STRINGS_MAX) THEN
      CALL RE_ALLOCATE_STRINGS(NM)
   ENDIF
   M%N_STRINGS = M%N_STRINGS + 1
   WRITE(M%STRING(M%N_STRINGS),'(A)') 'XYZ'
   M%N_STRINGS = M%N_STRINGS + 1
   WRITE(M%STRING(M%N_STRINGS),'(1X,A)') TRIM(FN_XYZ(NM))
ENDIF WRITE_XYZ_FILE

! Write name of terrain file

IF (TERRAIN_CASE) THEN
   ALLOCATE(Z_TERRAIN(0:M%IBAR,0:M%JBAR))
   ALLOCATE(OUT_OF_MESH(0:M%IBAR,0:M%JBAR)) ; OUT_OF_MESH = .FALSE.
   DO J=0,M%JBAR
      DO I=0,M%IBAR
         IF (CC_IBM) THEN
            Z_TERRAIN(I,J) = REAL(M%GEOM_ZMAX(I,J),FB)
         ELSE
            Z_TERRAIN(I,J) = REAL(0.25_EB*(M%Z_LS(I,J)+M%Z_LS(I+1,J)+M%Z_LS(I,J+1)+M%Z_LS(I+1,J+1)),FB)
         ENDIF
         IF (Z_TERRAIN(I,J)<M%ZS .OR. Z_TERRAIN(I,J)>M%ZF) OUT_OF_MESH(I,J) = .TRUE.
      ENDDO
   ENDDO
   DO J=0,M%JBAR
      DO I=0,M%IBAR
         IF (OUT_OF_MESH(I,J)) THEN
            IF (OUT_OF_MESH(MIN(M%IBAR,I+1),J) .AND. OUT_OF_MESH(MAX(0,I-1),J) .AND. &
                OUT_OF_MESH(I,MIN(M%JBAR,J+1)) .AND. OUT_OF_MESH(I,MAX(0,J-1))) Z_TERRAIN(I,J) = REAL(ZS_MIN-2._EB,FB)
         ENDIF
      ENDDO
   ENDDO
   IF (ANY(.NOT.OUT_OF_MESH)) THEN
      M%N_STRINGS = M%N_STRINGS + 1
      WRITE(M%STRING(M%N_STRINGS),'(A,I6)') 'TERRAIN',NM
      M%N_STRINGS = M%N_STRINGS + 1
      WRITE(M%STRING(M%N_STRINGS),'(1X,A)') TRIM(FN_TERRAIN(NM))
      OPEN(LU_TERRAIN(NM),FILE=FN_TERRAIN(NM),FORM='UNFORMATTED',STATUS='REPLACE')
      WRITE(LU_TERRAIN(NM)) REAL(ZS_MIN-1._EB,FB)
      WRITE(LU_TERRAIN(NM)) IBP1,JBP1
      WRITE(LU_TERRAIN(NM)) (M%XPLT(I),I=0,IBAR)
      WRITE(LU_TERRAIN(NM)) (M%YPLT(J),J=0,JBAR)
      WRITE(LU_TERRAIN(NM)) ((Z_TERRAIN(I,J),J=0,JBAR),I=0,IBAR)
      CLOSE(LU_TERRAIN(NM))
   ENDIF
   DEALLOCATE(Z_TERRAIN)
   DEALLOCATE(OUT_OF_MESH)
ENDIF

! Re-allocate IBLK array for use with isosurface generation

DEALLOCATE(M%IBLK)
ALLOCATE(M%IBLK(1:IBAR,1:JBAR,1:KBAR),STAT=IZERO)
CALL ChkMemErr('DUMP','IBLK',IZERO)

! Initialize isosurface file

   DO N=1,N_ISOF
      IS => ISOSURFACE_FILE(N)
      IF (APPEND) THEN
        OPEN(ABS(LU_ISOF(N,NM)),FILE=FN_ISOF(N,NM),FORM='UNFORMATTED',STATUS='OLD',POSITION='APPEND')
        IF(IS%INDEX2 /= -1 ) THEN
           OPEN(ABS(LU_ISOF2(N,NM)),FILE=FN_ISOF2(N,NM),FORM='UNFORMATTED',STATUS='OLD',POSITION='APPEND')
        ENDIF
      ELSE
        OPEN(ABS(LU_ISOF(N,NM)),FILE=FN_ISOF(N,NM),FORM='UNFORMATTED',STATUS='REPLACE')
        IF (IS%INDEX2 /= -1 ) THEN
           OPEN(ABS(LU_ISOF2(N,NM)),FILE=FN_ISOF2(N,NM),FORM='UNFORMATTED',STATUS='REPLACE')
        ENDIF
        IF (M%N_STRINGS+5>M%N_STRINGS_MAX) CALL RE_ALLOCATE_STRINGS(NM)
        M%N_STRINGS = M%N_STRINGS + 1
        IF (IS%INDEX2 .EQ. -1 ) THEN
           WRITE(M%STRING(M%N_STRINGS),'(A,I6,1X,I6,1X,E13.6)') 'ISOG',NM,IS%SKIP,IS%DELTA
        ELSE
           WRITE(M%STRING(M%N_STRINGS),'(A,I6,1X,I6,1X,E13.6)') 'TISOG',NM,IS%SKIP,IS%DELTA
        ENDIF
        M%N_STRINGS = M%N_STRINGS + 1
        WRITE(M%STRING(M%N_STRINGS),'(1X,A)') TRIM(FN_ISOF(N,NM)) ! geometry
        IF (IS%INDEX2 /= -1 ) THEN
           M%N_STRINGS = M%N_STRINGS + 1
           WRITE(M%STRING(M%N_STRINGS),'(1X,A)') TRIM(FN_ISOF2(N,NM)) ! data
        ENDIF
        M%N_STRINGS = M%N_STRINGS + 1
        WRITE(M%STRING(M%N_STRINGS),'(1X,A)') TRIM(IS%SMOKEVIEW_LABEL) ! labels for geometry
        M%N_STRINGS = M%N_STRINGS + 1
        WRITE(M%STRING(M%N_STRINGS),'(1X,A)') TRIM(IS%SMOKEVIEW_BAR_LABEL)
        M%N_STRINGS = M%N_STRINGS + 1
        WRITE(M%STRING(M%N_STRINGS),'(1X,A)') TRIM(OUTPUT_QUANTITY(IS%INDEX)%UNITS)
        IF (IS%INDEX2 /= -1 ) THEN
           M%N_STRINGS = M%N_STRINGS + 1
           WRITE(M%STRING(M%N_STRINGS),'(1X,A)') TRIM(IS%SMOKEVIEW_LABEL2) ! labels for data
           M%N_STRINGS = M%N_STRINGS + 1
           WRITE(M%STRING(M%N_STRINGS),'(1X,A)') TRIM(IS%SMOKEVIEW_BAR_LABEL2)
           M%N_STRINGS = M%N_STRINGS + 1
           WRITE(M%STRING(M%N_STRINGS),'(1X,A)') TRIM(OUTPUT_QUANTITY(IS%INDEX2)%UNITS)
        ENDIF
      ENDIF
   ENDDO

! Initialize Smoke3d file

SMOKE3D_INITIALIZATION: IF (SMOKE3D) THEN

   DO N=1,N_SMOKE3D
      IF (SMOKE3D_FILE(N)%QUANTITY_INDEX==0) CYCLE
      IF (APPEND) THEN
         OPEN(LU_SMOKE3D(N,NM),            FILE=FN_SMOKE3D(N,NM),            FORM='UNFORMATTED',STATUS='OLD',POSITION='APPEND')
         OPEN(LU_SMOKE3D(N+N_SMOKE3D,NM),  FILE=FN_SMOKE3D(N+N_SMOKE3D,NM),  FORM='FORMATTED',  STATUS='OLD',POSITION='APPEND')
         IF (SMOKE3D_16) THEN
            OPEN(LU_SMOKE3D(N+2*N_SMOKE3D,NM),FILE=FN_SMOKE3D(N+2*N_SMOKE3D,NM),FORM='UNFORMATTED',  STATUS='OLD',POSITION='APPEND')
         ENDIF
      ELSE
         OPEN(LU_SMOKE3D(N,NM),  FILE=FN_SMOKE3D(N,NM),  FORM='UNFORMATTED',STATUS='REPLACE')
         WRITE(LU_SMOKE3D(N,NM)) INTEGER_ONE,INTEGER_ZERO,0,M%IBAR,0,M%JBAR,0,M%KBAR

         OPEN(LU_SMOKE3D(N+N_SMOKE3D,NM),FILE=FN_SMOKE3D(N+N_SMOKE3D,NM),FORM='FORMATTED',STATUS='REPLACE')
         WRITE(LU_SMOKE3D(N+N_SMOKE3D,NM),*) INTEGER_ZERO

         IF (SMOKE3D_16) THEN
            SMOKE3D_16_COMPRESS = 0
            SMOKE3D_16_VERSION = 1
            OPEN(LU_SMOKE3D(N+2*N_SMOKE3D,NM), FILE=FN_SMOKE3D(N+2*N_SMOKE3D,NM),FORM='UNFORMATTED',STATUS='REPLACE')
            WRITE(LU_SMOKE3D(N+2*N_SMOKE3D,NM)) INTEGER_ONE,SMOKE3D_16_VERSION,SMOKE3D_16_COMPRESS,M%IBP1,M%JBP1,M%KBP1
         ENDIF
         IF (M%N_STRINGS+5>M%N_STRINGS_MAX) CALL RE_ALLOCATE_STRINGS(NM)
         M%N_STRINGS = M%N_STRINGS + 1
         WRITE(M%STRING(M%N_STRINGS),'(A,I6,F11.3)') 'SMOKF3D',NM,SMOKE3D_FILE(N)%MASS_EXTINCTION_COEFFICIENT
         M%N_STRINGS = M%N_STRINGS + 1
         WRITE(M%STRING(M%N_STRINGS),'(1X,A)') TRIM(FN_SMOKE3D(N,NM))
         M%N_STRINGS = M%N_STRINGS + 1
         WRITE(M%STRING(M%N_STRINGS),'(1X,A)') TRIM(SMOKE3D_FILE(N)%SMOKEVIEW_LABEL)
         M%N_STRINGS = M%N_STRINGS + 1
         WRITE(M%STRING(M%N_STRINGS),'(1X,A)') TRIM(SMOKE3D_FILE(N)%SMOKEVIEW_BAR_LABEL)
         M%N_STRINGS = M%N_STRINGS + 1
         WRITE(M%STRING(M%N_STRINGS),'(1X,A)') TRIM(OUTPUT_QUANTITY(SMOKE3D_FILE(N)%QUANTITY_INDEX)%UNITS)
      ENDIF
   ENDDO

ENDIF SMOKE3D_INITIALIZATION

! Initialize Slice Files

NTSL = 0

DO N=1,M%N_SLCF
   SL => M%SLICE(N)
   IF (.NOT.APPEND) THEN

   ! write out slice file info to .sf files

      OPEN(LU_SLCF(N,NM),             FILE=FN_SLCF(N,NM),               FORM='UNFORMATTED',STATUS='REPLACE')
      OPEN(LU_SLCF(N+N_SLCF_MAX,NM),  FILE=FN_SLCF(N + N_SLCF_MAX,NM),  FORM='FORMATTED',  STATUS='REPLACE')
      WRITE(LU_SLCF(N,NM)) SL%SMOKEVIEW_LABEL(1:30)
      WRITE(LU_SLCF(N,NM)) SL%SMOKEVIEW_BAR_LABEL(1:30)
      WRITE(LU_SLCF(N,NM)) OUTPUT_QUANTITY(SL%INDEX)%UNITS(1:30)
      IF (SL%RLE) THEN
         OPEN(LU_SLCF(N+2*N_SLCF_MAX,NM),FILE=FN_SLCF(N + 2*N_SLCF_MAX,NM),FORM='UNFORMATTED',STATUS='REPLACE')

  ! endian
  ! completion (0/1)
  ! fileversion (compressed format)
  ! version_local  (slicef version)
  ! global min max (used to perform conversion)
  ! i1,i2,j1,j2,k1,k2
         WRITE(LU_SLCF(N+2*N_SLCF_MAX,NM))1                       ! endian
         WRITE(LU_SLCF(N+2*N_SLCF_MAX,NM))1,1,1                   ! completion, file version, slice version
         WRITE(LU_SLCF(N+2*N_SLCF_MAX,NM))SL%RLE_MIN,SL%RLE_MAX   ! global min, global max
      ENDIF
      IF (.NOT.SL%TERRAIN_SLICE) THEN
         WRITE(LU_SLCF(N,NM))              SL%I1,SL%I2,SL%J1,SL%J2,SL%K1,SL%K2
         IF(SL%RLE)WRITE(LU_SLCF(N+2*N_SLCF_MAX,NM)) SL%I1,SL%I2,SL%J1,SL%J2,SL%K1,SL%K2
         WRITE(SLICEPARMS,'(A,I6,I6,I6,I6,I6,I6)') ' &',SL%I1,SL%I2,SL%J1,SL%J2,SL%K1,SL%K2
      ELSE
         NTSL = NTSL + 1
         M%K_AGL_SLICE(   0,SL%J1:SL%J2,NTSL) = M%K_AGL_SLICE(   1,SL%J1:SL%J2,NTSL)
         M%K_AGL_SLICE(IBP1,SL%J1:SL%J2,NTSL) = M%K_AGL_SLICE(IBAR,SL%J1:SL%J2,NTSL)
         M%K_AGL_SLICE(SL%I1:SL%I2,   0,NTSL) = M%K_AGL_SLICE(SL%I1:SL%I2,   1,NTSL)
         M%K_AGL_SLICE(SL%I1:SL%I2,JBP1,NTSL) = M%K_AGL_SLICE(SL%I1:SL%I2,JBAR,NTSL)
         WRITE(LU_SLCF(N,NM)) SL%I1,SL%I2,SL%J1,SL%J2,M%K_AGL_SLICE(SL%I1,SL%J1,NTSL),M%K_AGL_SLICE(SL%I1,SL%J1,NTSL)
         IF (SL%RLE) THEN
            WRITE(LU_SLCF(N+2*N_SLCF_MAX,NM)) SL%I1,SL%I2,SL%J1,SL%J2,&
                                              M%K_AGL_SLICE(SL%I1,SL%J1,NTSL),M%K_AGL_SLICE(SL%I1,SL%J1,NTSL)
         ENDIF
         WRITE(SLICEPARMS,'(A,I6,I6,I6,I6,I6,I6)') ' &',SL%I1,SL%I2,SL%J1,SL%J2,&
                            M%K_AGL_SLICE(SL%I1,SL%J1,NTSL),M%K_AGL_SLICE(SL%I1,SL%J1,NTSL)
      ENDIF

   ! write out slice file info to the .smv file

      IF (SL%SLICETYPE=='STRUCTURED') THEN
         IF (M%N_STRINGS+5>M%N_STRINGS_MAX) CALL RE_ALLOCATE_STRINGS(NM)
      ELSE
         IF (M%N_STRINGS+8>M%N_STRINGS_MAX) CALL RE_ALLOCATE_STRINGS(NM)
         M%N_STRINGS = M%N_STRINGS + 1
         WRITE(M%STRING(M%N_STRINGS),'(A,1x,I6)') 'SGEOM',0
         M%N_STRINGS = M%N_STRINGS + 1
         WRITE(M%STRING(M%N_STRINGS),'(1X,A)') TRIM(FN_SLCF_GEOM(N,NM))
      ENDIF
      M%N_STRINGS = M%N_STRINGS + 1

      IF (SL%CELL_CENTERED) THEN
         CC_VAL = 1
      ELSE
         CC_VAL = 0
      ENDIF
      IF (SL%ID/='null') THEN
         WRITE(SLICELABEL,'(A,A,A,A,A,A,I6,1X,I6,1X)') ' # ',TRIM(SL%SLICETYPE),' %',TRIM(SL%ID),TRIM(SLICEPARMS),&
                                                 ' ! ',SL%SLCF_INDEX, CC_VAL
      ELSE
         WRITE(SLICELABEL,'(A,A,A,A,I6,1X,I6,1X)') ' # ',TRIM(SL%SLICETYPE),TRIM(SLICEPARMS),&
                                             ' ! ',SL%SLCF_INDEX, CC_VAL
      ENDIF
      IF (SL%SLICETYPE=='STRUCTURED') THEN
         IF (SL%CELL_CENTERED) THEN
            WRITE(M%STRING(M%N_STRINGS),'(A,I6,A)') 'SLCC',NM,TRIM(SLICELABEL)
         ELSEIF (SL%TERRAIN_SLICE) THEN
            WRITE(M%STRING(M%N_STRINGS),'(A,I6,F10.4,A,1X,A,I6,1X)') 'SLCT',NM,SL%AGL_SLICE,TRIM(SLICEPARMS),' ! ',SL%SLCF_INDEX
         ELSE
            WRITE(M%STRING(M%N_STRINGS),'(A,I6,A)') 'SLCF',NM,TRIM(SLICELABEL)
         ENDIF
      ELSE
         WRITE(M%STRING(M%N_STRINGS),'(A,I6,A)') 'BNDS',NM,TRIM(SLICELABEL)
      ENDIF
      M%N_STRINGS = M%N_STRINGS + 1
      WRITE(M%STRING(M%N_STRINGS),'(1X,A)') TRIM(FN_SLCF(N,NM))
      IF (SL%SLICETYPE/='STRUCTURED') THEN
         M%N_STRINGS = M%N_STRINGS + 1
         WRITE(M%STRING(M%N_STRINGS),'(1X,A)') TRIM(FN_SLCF_GEOM(N,NM))
      ENDIF
      M%N_STRINGS = M%N_STRINGS + 1
      WRITE(M%STRING(M%N_STRINGS),'(1X,A)') TRIM(SL%SMOKEVIEW_LABEL)
      M%N_STRINGS = M%N_STRINGS + 1
      WRITE(M%STRING(M%N_STRINGS),'(1X,A)') TRIM(SL%SMOKEVIEW_BAR_LABEL)
      M%N_STRINGS = M%N_STRINGS + 1
      WRITE(M%STRING(M%N_STRINGS),'(1X,A)') TRIM(OUTPUT_QUANTITY(SL%INDEX)%UNITS)

      CLOSE(LU_SLCF(N,NM))
      CLOSE(LU_SLCF(N+N_SLCF_MAX,NM))
      IF(SL%RLE)CLOSE(LU_SLCF(N+2*N_SLCF_MAX,NM))
   ENDIF
ENDDO

! Initialize Boundary Files

IF_BOUNDARY_FILES: IF (N_BNDF>0) THEN

   I1B = MAX(IBP1,JBP1)
   I2B = MAX(JBP1,KBP1)
   ALLOCATE(M%PP(0:I1B,0:I2B),STAT=IZERO)
   CALL ChkMemErr('DUMP','PP',IZERO)
   M%PP = 0._EB
   ALLOCATE(M%PPN(0:I1B,0:I2B),STAT=IZERO)
   CALL ChkMemErr('DUMP','PPN',IZERO)
   ALLOCATE(M%IBK(0:I1B,0:I2B),STAT=IZERO)
   CALL ChkMemErr('DUMP','IBK',IZERO)

   ! Create an array of PATCHes that holds the parameters of each boundary patch

   CREATE_PATCHES: IF (.NOT.APPEND) THEN

      ! Create an array INC that indicates which face of which obstruction is to be painted with boundary values

      ALLOCATE(PAINT_FACE(0:M%N_OBST,-3:3),STAT=IZERO) ; CALL ChkMemErr('DUMP','PAINT_FACE',IZERO) ; PAINT_FACE = .FALSE.
      DO IW=1,M%N_EXTERNAL_WALL_CELLS+M%N_INTERNAL_WALL_CELLS
         WC => M%WALL(IW)
         BC => M%BOUNDARY_COORD(WC%BC_INDEX)
         IF (WC%BOUNDARY_TYPE==SOLID_BOUNDARY .OR. WC%BOUNDARY_TYPE==NULL_BOUNDARY) PAINT_FACE(WC%OBST_INDEX,BC%IOR) = .TRUE.
         IF (.NOT.BNDF_DEFAULT .AND. WC%OBST_INDEX==0) PAINT_FACE(WC%OBST_INDEX,BC%IOR) = .FALSE.
      ENDDO

      ! Count and allocate the PATCHes

      M%N_PATCH = 0
      DO N=0,M%N_OBST
         OB=>M%OBSTRUCTION(N)
         DO IOR=-3,3
            IF (.NOT.OB%SHOW_BNDF(IOR)) PAINT_FACE(N,IOR) = .FALSE.
            IF (ABS(IOR)==2 .AND. TWO_D) PAINT_FACE(N,IOR) = .FALSE.
            IF (PAINT_FACE(N,IOR)) M%N_PATCH = M%N_PATCH + 1
         ENDDO
      ENDDO

      ALLOCATE(M%PATCH(M%N_PATCH),STAT=IZERO)
      CALL ChkMemErr('DUMP','PATCH',IZERO)

      ! Assign coordinate indices for each PATCH

      IP = 0
      M%N_BNDF_POINTS = 0
      DO N=0,M%N_OBST
         OB=>M%OBSTRUCTION(N)
         DO IOR=-3,3
            IF (.NOT.PAINT_FACE(N,IOR)) CYCLE
            IP = IP + 1
            PA => M%PATCH(IP)
            IF (N==0) THEN
               PA%I1 = 0     ; PA%IG1 = 1
               PA%I2 = IBAR  ; PA%IG2 = IBAR
               PA%J1 = 0     ; PA%JG1 = 1
               PA%J2 = JBAR  ; PA%JG2 = JBAR
               PA%K1 = 0     ; PA%KG1 = 1
               PA%K2 = KBAR  ; PA%KG2 = KBAR
               SELECT CASE(IOR)
                  CASE( 1) ; PA%I2 = PA%I1 ; PA%IG2 = PA%IG1
                  CASE(-1) ; PA%I1 = PA%I2 ; PA%IG1 = PA%IG2
                  CASE( 2) ; PA%J2 = PA%J1 ; PA%JG2 = PA%JG1
                  CASE(-2) ; PA%J1 = PA%J2 ; PA%JG1 = PA%JG2
                  CASE( 3) ; PA%K2 = PA%K1 ; PA%KG2 = PA%KG1
                  CASE(-3) ; PA%K1 = PA%K2 ; PA%KG1 = PA%KG2
               END SELECT
            ELSE
               PA%I1 = OB%I1 ; PA%IG1 = OB%I1+1
               PA%I2 = OB%I2 ; PA%IG2 = OB%I2
               PA%J1 = OB%J1 ; PA%JG1 = OB%J1+1
               PA%J2 = OB%J2 ; PA%JG2 = OB%J2
               PA%K1 = OB%K1 ; PA%KG1 = OB%K1+1
               PA%K2 = OB%K2 ; PA%KG2 = OB%K2
               SELECT CASE(IOR)
                  CASE(-1) ; PA%I2 = PA%I1 ; PA%IG1=PA%IG1-1 ; PA%IG2 = PA%IG1
                  CASE( 1) ; PA%I1 = PA%I2 ; PA%IG2=PA%IG2+1 ; PA%IG1 = PA%IG2
                  CASE(-2) ; PA%J2 = PA%J1 ; PA%JG1=PA%JG1-1 ; PA%JG2 = PA%JG1
                  CASE( 2) ; PA%J1 = PA%J2 ; PA%JG2=PA%JG2+1 ; PA%JG1 = PA%JG2
                  CASE(-3) ; PA%K2 = PA%K1 ; PA%KG1=PA%KG1-1 ; PA%KG2 = PA%KG1
                  CASE( 3) ; PA%K1 = PA%K2 ; PA%KG2=PA%KG2+1 ; PA%KG1 = PA%KG2
               END SELECT
            ENDIF
            PA%IOR        = IOR
            PA%OBST_INDEX = N
            M%N_BNDF_POINTS = M%N_BNDF_POINTS + (PA%IG2-PA%IG1+1)*(PA%JG2-PA%JG1+1)*(PA%KG2-PA%KG1+1)
         ENDDO
      ENDDO

      DEALLOCATE(PAINT_FACE)

   ENDIF CREATE_PATCHES

   IF (BNDF_TIME_INTEGRALS>0) THEN
      ALLOCATE(M%BNDF_TIME_INTEGRAL(M%N_BNDF_POINTS,BNDF_TIME_INTEGRALS),STAT=IZERO)
      CALL ChkMemErr('DUMP','BNDF_TIME_INTEGRAL',IZERO)
      M%BNDF_TIME_INTEGRAL = 0._FB
   ENDIF

ENDIF IF_BOUNDARY_FILES

BOUNDARY_FILES: DO NF=1,N_BNDF

   IF (M%N_PATCH==0) EXIT BOUNDARY_FILES

   BF => BOUNDARY_FILE(NF)

   RESTART: IF (APPEND) THEN
      OPEN(LU_BNDF(NF,NM),FILE=FN_BNDF(NF,NM),FORM='UNFORMATTED',STATUS='OLD',POSITION='APPEND')
      OPEN(LU_BNDF(NF+N_BNDF,NM),FILE=FN_BNDF(NF+N_BNDF,NM),FORM='FORMATTED',STATUS='OLD',POSITION='APPEND')
   ELSE RESTART
      IF (M%N_STRINGS+5>M%N_STRINGS_MAX) CALL RE_ALLOCATE_STRINGS(NM)
      M%N_STRINGS = M%N_STRINGS + 1
      IF (BF%CELL_CENTERED) THEN
         WRITE(M%STRING(M%N_STRINGS),'(A,2I6)') 'BNDC',NM,1
      ELSE
         WRITE(M%STRING(M%N_STRINGS),'(A,2I6)') 'BNDF',NM,1
      ENDIF
      M%N_STRINGS = M%N_STRINGS + 1
      WRITE(M%STRING(M%N_STRINGS),'(1X,A)') TRIM(FN_BNDF(NF,NM))
      M%N_STRINGS = M%N_STRINGS + 1
      WRITE(M%STRING(M%N_STRINGS),'(1X,A)') TRIM(BF%SMOKEVIEW_LABEL)
      M%N_STRINGS = M%N_STRINGS + 1
      WRITE(M%STRING(M%N_STRINGS),'(1X,A)') TRIM(BF%SMOKEVIEW_BAR_LABEL)
      M%N_STRINGS = M%N_STRINGS + 1
      WRITE(M%STRING(M%N_STRINGS),'(1X,A)') TRIM(BF%UNITS)
      OPEN(LU_BNDF(NF,NM),FILE=FN_BNDF(NF,NM),FORM='UNFORMATTED',STATUS='REPLACE')
      OPEN(LU_BNDF(NF+N_BNDF,NM),FILE=FN_BNDF(NF+N_BNDF,NM),FORM='FORMATTED',STATUS='REPLACE')
      WRITE(LU_BNDF(NF,NM)) BF%SMOKEVIEW_LABEL(1:30)
      WRITE(LU_BNDF(NF,NM)) BF%SMOKEVIEW_BAR_LABEL(1:30)
      WRITE(LU_BNDF(NF,NM)) BF%UNITS(1:30)
      WRITE(LU_BNDF(NF,NM)) M%N_PATCH
      DO IP=1,M%N_PATCH
         PA=>M%PATCH(IP)
         WRITE(LU_BNDF(NF,NM)) PA%I1,PA%I2,PA%J1,PA%J2,PA%K1,PA%K2,PA%IOR,PA%OBST_INDEX,NM
      ENDDO
   ENDIF RESTART

ENDDO BOUNDARY_FILES

! Initialize particle dump file

PARTICLE_IF: IF (PARTICLE_FILE) THEN

   APPEND_PARTICLE_FILE: IF (APPEND) THEN

      OPEN(LU_PART(NM),FILE=FN_PART(NM),FORM='UNFORMATTED',STATUS='OLD',POSITION='APPEND')
      OPEN(LU_PART(NM+NMESHES),FILE=FN_PART(NM+NMESHES),FORM='FORMATTED',STATUS='OLD',POSITION='APPEND')

   ELSE APPEND_PARTICLE_FILE

      IF (M%N_STRINGS+10*N_LAGRANGIAN_CLASSES>M%N_STRINGS_MAX) CALL RE_ALLOCATE_STRINGS(NM)
      N = M%N_STRINGS_MAX/MAX(1,N_LAGRANGIAN_CLASSES)
      M%N_STRINGS = M%N_STRINGS + 1
      WRITE(M%STRING(M%N_STRINGS),'(A,I6)') 'PRT5',NM
      M%N_STRINGS = M%N_STRINGS + 1
      WRITE(M%STRING(M%N_STRINGS),'(1X,A)') TRIM(FN_PART(NM))
      M%N_STRINGS = M%N_STRINGS + 1
      WRITE(M%STRING(M%N_STRINGS),'(I7)') N_LAGRANGIAN_CLASSES

      DO N=1,N_LAGRANGIAN_CLASSES
         IF (M%N_STRINGS + 1 > M%N_STRINGS_MAX) CALL RE_ALLOCATE_STRINGS(NM) !reallocate if # PART lines requires it
         M%N_STRINGS = M%N_STRINGS + 1
         WRITE(M%STRING(M%N_STRINGS),'(I7)') N
      ENDDO

      OPEN(LU_PART(NM),FILE=FN_PART(NM),FORM='UNFORMATTED',STATUS='REPLACE')
      OPEN(LU_PART(NM+NMESHES),FILE=FN_PART(NM+NMESHES),FORM='FORMATTED',STATUS='REPLACE')
      WRITE(LU_PART(NM)) INTEGER_ONE                ! The number ONE, to indicate file Endian-ness
      WRITE(LU_PART(NM)) NINT(VERSION_NUMBER*100.)  ! FDS version number
      WRITE(LU_PART(NM)) N_LAGRANGIAN_CLASSES
      DO N=1,N_LAGRANGIAN_CLASSES
         LPC => LAGRANGIAN_PARTICLE_CLASS(N)
         WRITE(LU_PART(NM)) LPC%N_QUANTITIES,INTEGER_ZERO  ! INTEGER_ZERO is a place holder for future INTEGER quantities
         DO NN=1,LPC%N_QUANTITIES
            WRITE(LU_PART(NM)) LPC%SMOKEVIEW_LABEL(NN)(1:30)
            WRITE(LU_PART(NM)) OUTPUT_QUANTITY(LPC%QUANTITIES_INDEX(NN))%UNITS(1:30)
         ENDDO
      ENDDO

   ENDIF APPEND_PARTICLE_FILE
ENDIF PARTICLE_IF

! Initialize PROFile data files (CHID_prof_nn.csv)

PROF_LOOP: DO N=1,N_PROF
   IF (PROFILE(N)%MESH /= NM) CYCLE PROF_LOOP
   IF (APPEND .AND. PROFILE(N)%FORMAT_INDEX==1) THEN
      OPEN(LU_PROF(N),FILE=FN_PROF(N),FORM='FORMATTED',STATUS='OLD',POSITION='APPEND')
   ELSE
      OPEN(LU_PROF(N),FILE=FN_PROF(N),FORM='FORMATTED',STATUS='REPLACE')
      IF (PROFILE(N)%FORMAT_INDEX==1) THEN
         WRITE(LU_PROF(N),'(A)') PROFILE(N)%ID
         WRITE(LU_PROF(N),'(A)') "Time(s), Npoints, Npoints x Depth (m), Npoints x Value"
         WRITE(LU_PROF(N),*)
      ENDIF
   ENDIF
ENDDO PROF_LOOP

! Initialize radiation file (RADF)

DO N=1,M%N_RADF
   RF => M%RAD_FILE(N)
   IF (.NOT.APPEND) THEN
      OPEN(LU_RADF(N,NM),FILE=FN_RADF(N,NM),FORM='FORMATTED',STATUS='REPLACE')
      WRITE(LU_RADF(N,NM),'(A)') 'NSTEPS'
      NSTEPS = SIZE(RADF_CLOCK)
      WRITE(LU_RADF(N,NM),'(I4)') NSTEPS
      WRITE(LU_RADF(N,NM),'(/A)') 'TIMES'
      DO NN=0,NSTEPS-1
         WRITE(LU_RADF(N,NM),'(F8.2)') RADF_CLOCK(NN)
      ENDDO
      WRITE(LU_RADF(N,NM),'(/A)') 'NP'
      WRITE(LU_RADF(N,NM),'(I8)') RF%N_POINTS
      WRITE(LU_RADF(N,NM),'(/A)') 'XYZ_INTENSITIES'
      DO K=RF%K1,RF%K2,RF%K_STEP
         DO J=RF%J1,RF%J2,RF%J_STEP
            DO I=RF%I1,RF%I2,RF%I_STEP
               WRITE(LU_RADF(N,NM),'(3F8.3)') M%XC(I),M%YC(J),M%ZC(K)
            ENDDO
         ENDDO
      ENDDO
      WRITE(LU_RADF(N,NM),'(/A)') 'NI'
      WRITE(LU_RADF(N,NM),'(I4)') NUMBER_RADIATION_ANGLES
      WRITE(LU_RADF(N,NM),'(/A)') 'XYZ_DIRECTIONS'
      DO NN=1,NUMBER_RADIATION_ANGLES
         NRM = NORM2([DLX(NN),DLY(NN),DLZ(NN)])
         WRITE(LU_RADF(N,NM),'(3F7.3)') DLX(NN)/NRM,DLY(NN)/NRM,DLZ(NN)/NRM
      ENDDO
   ELSE
      OPEN(LU_RADF(N,NM),FILE=FN_RADF(N,NM),FORM='FORMATTED',STATUS='OLD',POSITION='APPEND')
   ENDIF
ENDDO

T_USED(7) = T_USED(7) + CURRENT_TIME() - TNOW
END SUBROUTINE INITIALIZE_MESH_DUMPS









!> \brief Write out the SMOKE3D data to files
!>
!> \param T Current simulation time (s)
!> \param DT Current time step size (s)
!> \param NM Mesh number

SUBROUTINE DUMP_SMOKE3D(T,DT,NM)

USE ISOSMOKE, ONLY: SMOKE3D_TO_FILE
REAL(EB), INTENT(IN) :: T,DT
INTEGER,  INTENT(IN) :: NM
INTEGER  :: I,J,K,N
REAL(FB) :: DXX,STIME
REAL(EB), POINTER, DIMENSION(:,:,:) :: FF
REAL(FB), ALLOCATABLE, DIMENSION(:) :: QQ_PACK
REAL(EB) :: FR_C
TYPE(SMOKE3D_TYPE), POINTER :: S3

CALL POINT_TO_MESH(NM)

! Miscellaneous settings

DRY   = .FALSE.
STIME = REAL(T_BEGIN + (T-T_BEGIN)*TIME_SHRINK_FACTOR,FB)
DXX   = REAL(DX(1),FB)
FF   => WORK3

DATA_FILE_LOOP: DO N=1,N_SMOKE3D

   S3 => SMOKE3D_FILE(N)
   IF (S3%QUANTITY_INDEX==0) CYCLE

   ! Obtain Smoke3D output at cell centers

   DO K=0,KBP1
      DO J=0,JBP1
         DO I=0,IBP1
            FF(I,J,K)=GAS_PHASE_OUTPUT(T,DT,NM,I,J,K,S3%QUANTITY_INDEX,0,S3%Y_INDEX,S3%Z_INDEX,0,0,0,0,0,0)
         ENDDO
      ENDDO
   ENDDO

   ! Adjust the temperature as it is used in the expression for the radiation source term

   IF (S3%DISPLAY_TYPE=='TEMPERATURE' .AND. RTE_SOURCE_CORRECTION) THEN
      FR_C = RTE_SOURCE_CORRECTION_FACTOR**0.25_EB
      WHERE (CHI_R*Q>QR_CLIP) FF = (FF+TMPM)*FR_C - TMPM
   ENDIF

   ! Interpolate data to cell nodes

   DO K=0,KBAR
      DO J=0,JBAR
         DO I=0,IBAR
            QQ(I,J,K,1) = REAL((FF(I,J,K)  +FF(I+1,J,K)  +FF(I,J,K+1)  +FF(I+1,J,K+1)+ &
                                FF(I,J+1,K)+FF(I+1,J+1,K)+FF(I,J+1,K+1)+FF(I+1,J+1,K+1))*0.125_FB,FB)
         ENDDO
      ENDDO
   ENDDO

   IF (CC_IBM) THEN
      DO K=0,KBAR
         DO J=0,JBAR
            DO I=0,IBAR
               IF(MESHES(NM)%VERTVAR(I,J,K,CC_VGSC) /= CC_SOLID) CYCLE
               QQ(I,J,K,1) = 0._FB
            ENDDO
         ENDDO
      ENDDO
   ENDIF

   ! Pack the data into a 1-D array and send to the routine that writes the file for Smokeview

   ALLOCATE(QQ_PACK(IBP1*JBP1*KBP1))
   QQ_PACK = PACK(QQ(0:IBAR,0:JBAR,0:KBAR,1),MASK=.TRUE.)
   CALL SMOKE3D_TO_FILE(NM,STIME,DXX,N,QQ_PACK,IBP1,JBP1,KBP1,SMOKE3D_16)
   DEALLOCATE(QQ_PACK)

ENDDO DATA_FILE_LOOP

END SUBROUTINE DUMP_SMOKE3D







! \brief Write contour slices, Plot3D data, or 3d slices to a file
!>
!> \param T Current simulation time (s)
!> \param DT Current time step size (s)
!> \param NM Mesh number
!> \param IFRMT Slice (IFRMT=0) or Plot3D (IFRMT=1) or 3D slice (IFRMT=2)

SUBROUTINE DUMP_SLCF(T,DT,NM,IFRMT)

USE MEMORY_FUNCTIONS, ONLY: RE_ALLOCATE_STRINGS
USE GEOMETRY_FUNCTIONS, ONLY: SEARCH_OTHER_MESHES
USE TRAN, ONLY : GET_IJK
USE ISOSMOKE, ONLY: SLICE_TO_RLEFILE
INTEGER, INTENT(IN) :: NM,IFRMT
REAL(EB), INTENT(IN) :: T,DT
REAL(EB) :: BSUM,TT
INTEGER :: I,J,K,NQT,I1,I2,J1,J2,K1,K2,ITM,ITM1,IQ,IQ2,IQ3,IQQ,IND,IND2,II1,II2,JJ1,JJ2,KK1,KK2, &
           IC,Y_INDEX,Z_INDEX,PART_INDEX,VELO_INDEX,PROP_INDEX,REAC_INDEX,MATL_INDEX,NOM,IIO,JJO,KKO,I_INC,J_INC
INTEGER :: KTS,NTSL
REAL(EB), POINTER, DIMENSION(:,:,:) :: B,S,QUANTITY
REAL(FB) :: ZERO,STIME
LOGICAL :: PLOT3D,SLCF3D
LOGICAL :: AGL_TERRAIN_SLICE,CC_CELL_CENTERED,CC_INTERP2FACES
REAL(FB) :: SLICE_MIN, SLICE_MAX, DSLICE
INTEGER :: NX, NY, NZ
INTEGER :: IFACT, JFACT, KFACT
REAL(FB), ALLOCATABLE, DIMENSION(:) :: QQ_PACK
REAL(FB) :: UVEL, VVEL, WVEL, VEL, PLOT3D_MIN, PLOT3D_MAX

! Return if there are no slices to process and this is not a Plot3D dump

DRY=.FALSE.

SELECT CASE(IFRMT)
   CASE(0) ; PLOT3D=.FALSE. ; SLCF3D=.FALSE.
   CASE(1) ; PLOT3D=.TRUE.  ; SLCF3D=.FALSE.
   CASE(2) ; PLOT3D=.FALSE. ; SLCF3D=.TRUE.
END SELECT

IF (MESHES(NM)%N_SLCF==0 .AND. .NOT.PLOT3D) RETURN

CALL POINT_TO_MESH(NM)

! Create an array, B, that is 1 in any cell that is to be included in the 8-cell corner average, 0 otherwise.

B => WORK1
B = 1._EB

DO IC=1,CELL_COUNT(NM)
   IF (CELL(IC)%SOLID) B(CELL(IC)%I,CELL(IC)%J,CELL(IC)%K) = 0._EB
   IF (CELL(IC)%EXTERIOR) THEN
      IF (CELL(IC)%EXTERIOR_EDGE) THEN
         B(CELL(IC)%I,CELL(IC)%J,CELL(IC)%K) = 0._EB
      ELSE
         CALL SEARCH_OTHER_MESHES(XC(CELL(IC)%I),YC(CELL(IC)%J),ZC(CELL(IC)%K),NOM,IIO,JJO,KKO)
         IF (NOM==0) B(CELL(IC)%I,CELL(IC)%J,CELL(IC)%K) = 0._EB
      ENDIF
   ENDIF
ENDDO

! Create an array, S, that is the reciprocal of the sum of the B values at cell corner (I,J,K).

S => WORK2
S = 0._EB

DO K=0,KBAR
   DO J=0,JBAR
      DO I=0,IBAR
         BSUM = B(I,J,K)+B(I+1,J+1,K+1)+B(I+1,J,K)+B(I,J+1,K)+B(I,J,K+1)+B(I+1,J+1,K)+B(I+1,J,K+1)+B(I,J+1,K+1)
         IF (BSUM>0._EB) S(I,J,K) = 1._EB/BSUM
      ENDDO
   ENDDO
ENDDO

! If sprinkler diagnostic on, pre-compute various PARTICLE flux output

IF (.NOT.PLOT3D) THEN
   IF (SLCF_PARTICLE_FLUX) CALL COMPUTE_PARTICLE_FLUXES(NM)
ELSE
   IF (PL3D_PARTICLE_FLUX) CALL COMPUTE_PARTICLE_FLUXES(NM)
ENDIF

! Determine slice or Plot3D indicies

QUANTITY=>WORK7

IF (PLOT3D) THEN  ! Write out information to .smv file
   TT   = T_BEGIN + (T-T_BEGIN)*TIME_SHRINK_FACTOR
   ITM  = INT(TT)
   ITM1 = NINT(ABS(TT-ITM)*100)
   IF (ITM1==100) THEN
      ITM = ITM+1
      ITM1 = 0
   ENDIF
   WRITE(FN_PL3D(NM),'(A,A,I0,A,I0,A,I2.2,A)') TRIM(CHID),'_',NM,'_',ITM,'p',ITM1,'.q'
   WRITE(FN_PL3D(NM+NMESHES),'(A,A,I0,A,I0,A,I2.2,A)') TRIM(CHID),'_',NM,'_',ITM,'p',ITM1,'.q.bnd'
   IF (N_STRINGS+17>N_STRINGS_MAX) THEN
      CALL RE_ALLOCATE_STRINGS(NM)
      STRING => MESHES(NM)%STRING
   ENDIF
   N_STRINGS = N_STRINGS + 1
   WRITE(STRING(N_STRINGS),'(A,I8,A,I0,I6)')  'PL3D ',ITM,'.',ITM1,NM
   N_STRINGS = N_STRINGS + 1
   WRITE(STRING(N_STRINGS),'(1X,A)') TRIM(FN_PL3D(NM))
   DO IQ=1,5
      N_STRINGS = N_STRINGS + 1
      WRITE(STRING(N_STRINGS),'(1X,A)') TRIM(PLOT3D_SMOKEVIEW_LABEL(IQ))
      N_STRINGS = N_STRINGS + 1
      WRITE(STRING(N_STRINGS),'(1X,A)') TRIM(PLOT3D_SMOKEVIEW_BAR_LABEL(IQ))
      N_STRINGS = N_STRINGS + 1
      WRITE(STRING(N_STRINGS),'(1X,A)') TRIM(OUTPUT_QUANTITY(PLOT3D_QUANTITY_INDEX(IQ))%UNITS)
   ENDDO
   OPEN(LU_PL3D(NM),FILE=FN_PL3D(NM),FORM='UNFORMATTED',STATUS='REPLACE')
   OPEN(LU_PL3D(NM+NMESHES),FILE=FN_PL3D(NM+NMESHES),FORM='FORMATTED',STATUS='REPLACE')
ENDIF

! Loop through all the slice files or the 5 Plot3D quantities

IF (PLOT3D) THEN
   NQT = 5
ELSE
   NQT = N_SLCF
ENDIF

NTSL = 0

QUANTITY_LOOP: DO IQ=1,NQT

   IF (PLOT3D) THEN
      IND = PLOT3D_QUANTITY_INDEX(IQ)
      Y_INDEX = PLOT3D_Y_INDEX(IQ)
      Z_INDEX = PLOT3D_Z_INDEX(IQ)
      PART_INDEX = PLOT3D_PART_INDEX(IQ)
      VELO_INDEX = PLOT3D_VELO_INDEX(IQ)
      PROP_INDEX = 0
      I1  = 0
      I2  = IBAR
      J1  = 0
      J2  = JBAR
      K1  = 0
      K2  = KBAR
      AGL_TERRAIN_SLICE = .FALSE.
      CC_CELL_CENTERED  = .FALSE.
      CC_INTERP2FACES   = .FALSE.
   ELSE
      SL => SLICE(IQ)
      IND  = SL%INDEX
      IND2 = SL%INDEX2
      Y_INDEX = SL%Y_INDEX
      Z_INDEX = SL%Z_INDEX
      PART_INDEX = SL%PART_INDEX
      VELO_INDEX = SL%VELO_INDEX
      PROP_INDEX = SL%PROP_INDEX
      REAC_INDEX = SL%REAC_INDEX
      MATL_INDEX = SL%MATL_INDEX
      I1  = SL%I1
      I2  = SL%I2
      J1  = SL%J1
      J2  = SL%J2
      K1  = SL%K1
      K2  = SL%K2
      AGL_TERRAIN_SLICE = SL%TERRAIN_SLICE
      CC_CELL_CENTERED  = SL%CELL_CENTERED
      CC_INTERP2FACES   = .FALSE.
      IF(.NOT.CC_CELL_CENTERED .AND. TRIM(SL%SLICETYPE)/='STRUCTURED') CC_INTERP2FACES = .TRUE.
      IF ((I2-I1>0 .AND. J2-J1>0 .AND. K2-K1>0)  .AND. .NOT.SLCF3D) CYCLE QUANTITY_LOOP
      IF ((I2-I1==0 .OR. J2-J1==0 .OR. K2-K1==0) .AND.      SLCF3D) CYCLE QUANTITY_LOOP
   ENDIF

   ! Determine what cells need to be evaluated to form cell-corner averages

   II1 = I1
   II2 = I2+1
   JJ1 = J1
   JJ2 = J2+1
   KK1 = K1
   KK2 = K2+1

   SELECT CASE(OUTPUT_QUANTITY(IND)%CELL_POSITION)
      CASE(CELL_FACE)
         IF (OUTPUT_QUANTITY(IND)%IOR==1) II2 = I2
         IF (OUTPUT_QUANTITY(IND)%IOR==2) JJ2 = J2
         IF (OUTPUT_QUANTITY(IND)%IOR==3) KK2 = K2
      CASE(CELL_EDGE)
         II2 = I2
         JJ2 = J2
         KK2 = K2
   END SELECT

   ! Loop through the necessary cells, storing the desired output QUANTITY

   IF (.NOT.AGL_TERRAIN_SLICE) THEN
      DO K=KK1,KK2
         DO J=JJ1,JJ2
            DO I=II1,II2
               QUANTITY(I,J,K) = GAS_PHASE_OUTPUT(T,DT,NM,I,J,K,IND,IND2,Y_INDEX,Z_INDEX,PART_INDEX,VELO_INDEX,0,&
                                                  PROP_INDEX,REAC_INDEX,MATL_INDEX)
            ENDDO
         ENDDO
      ENDDO
   ELSE
      NTSL = NTSL + 1
      DO I=II1,II2
         DO J=JJ1,JJ2
            KTS = K_AGL_SLICE(I,J,NTSL)
            QUANTITY(I,J,K1) = GAS_PHASE_OUTPUT(T,DT,NM,I,J,KTS,IND,IND2,Y_INDEX,Z_INDEX,PART_INDEX,VELO_INDEX,0,0,0,0)
         ENDDO
      ENDDO
   ENDIF

   ! Average the QUANTITY at cell nodes, faces, or edges, as appropriate

   IF (PLOT3D) THEN
      IQQ = IQ
   ELSE
      IQQ = 1
   ENDIF

   IF (AGL_TERRAIN_SLICE) THEN

      I_INC = 1
      J_INC = 1
      IF (OUTPUT_QUANTITY(IND)%CELL_POSITION==CELL_FACE .AND. OUTPUT_QUANTITY(IND)%IOR==1) I_INC = 0
      IF (OUTPUT_QUANTITY(IND)%CELL_POSITION==CELL_FACE .AND. OUTPUT_QUANTITY(IND)%IOR==2) J_INC = 0

      DO J=J1,J2
         DO I=I1,I2
            QQ(I,J,K1,IQQ) = REAL(0.25_EB*(QUANTITY(I,J      ,K1)+QUANTITY(I+I_INC,J      ,K1)+&
                                           QUANTITY(I,J+J_INC,K1)+QUANTITY(I+I_INC,J+J_INC,K1)),FB)
         ENDDO
      ENDDO

   ELSEIF (CC_CELL_CENTERED) THEN

      DO K=KK1,KK2
         DO J=JJ1,JJ2
            DO I=II1,II2
               QQ(I,J,K,IQQ) = REAL(QUANTITY(I,J,K),FB)
            ENDDO
         ENDDO
      ENDDO

   ELSEIF (CC_INTERP2FACES) THEN

      DO K=KK1,KK2
         DO J=JJ1,JJ2
            DO I=II1,II2
            !xxx need to change the following code to use face centered interpolation
            ! (perhaps copy some variant of node centered interpolation code above)
               QQ(I,J,K,IQQ) = REAL(QUANTITY(I,J,K),FB)
            ENDDO
         ENDDO
      ENDDO

   ELSE  ! Node interpolated slice

      DO K=K1,K2
         DO J=J1,J2
            DO I=I1,I2
               SELECT CASE(OUTPUT_QUANTITY(IND)%CELL_POSITION)
                  CASE(CELL_CENTER)
                     QQ(I,J,K,IQQ) = REAL(CORNER_VALUE(QUANTITY,B,S,IND),FB)
                  CASE(CELL_FACE)
                     QQ(I,J,K,IQQ) = REAL(FACE_VALUE(),FB)
                  CASE(CELL_EDGE)
                     QQ(I,J,K,IQQ) = REAL(EDGE_VALUE(QUANTITY,S,IND),FB)
               END SELECT
            ENDDO
         ENDDO
      ENDDO

   ENDIF

   ! Dump out the slice file to a .sf file

   IF (.NOT.PLOT3D) THEN
      SL => SLICE(IQ)
      IF (SL%SLICETYPE=='STRUCTURED') THEN ! write out slice file using original slice file format
         STIME = REAL(T_BEGIN + (T-T_BEGIN)*TIME_SHRINK_FACTOR,FB)
         OPEN(LU_SLCF(IQ,NM),FILE=FN_SLCF(IQ,NM),FORM='UNFORMATTED',STATUS='OLD',POSITION='APPEND')
         WRITE(LU_SLCF(IQ,NM)) STIME
         IF (.NOT. SL%DEBUG) WRITE(LU_SLCF(IQ,NM)) (((QQ(I,J,K,1),I=I1,I2),J=J1,J2),K=K1,K2)
         IF (SL%DEBUG) THEN
            IF (J1 .NE. J2 .AND. K1 .NE. K2 ) THEN
               SLICE_MIN = MESHES(NM)%YPLT(J1) - STIME
               SLICE_MAX = MESHES(NM)%YPLT(J2) + STIME
               DSLICE = (SLICE_MAX - SLICE_MIN)/REAL(J2-J1, FB)
               WRITE(LU_SLCF(IQ,NM)) (((SLICE_MIN + REAL(J-J1,FB)*DSLICE,I=I1,I2),J=J1,J2),K=K1,K2)
            ELSE IF (I1 .NE. I2 .AND. K1 .NE. K2)THEN
               SLICE_MIN = MESHES(NM)%ZPLT(K1) - STIME
               SLICE_MAX = MESHES(NM)%ZPLT(K2) + STIME
               DSLICE = (SLICE_MAX - SLICE_MIN)/REAL(K2-K1, FB)
               WRITE(LU_SLCF(IQ,NM)) (((SLICE_MIN + REAL(K-K1,FB)*DSLICE,I=I1,I2),J=J1,J2),K=K1,K2)
            ELSE
               SLICE_MIN = MESHES(NM)%XPLT(I1) - STIME
               SLICE_MAX = MESHES(NM)%XPLT(I2) + STIME
               IF (I1 .EQ. I2 ) THEN
                  DSLICE = 0.0_FB
               ELSE
                  DSLICE = (SLICE_MAX - SLICE_MIN)/REAL(I2-I1, FB)
               ENDIF
               WRITE(LU_SLCF(IQ,NM)) (((SLICE_MIN + REAL(I-I1,FB)*DSLICE,I=I1,I2),J=J1,J2),K=K1,K2)
            ENDIF
         ENDIF
         CLOSE(LU_SLCF(IQ,NM))

         IF (SL%RLE) THEN
            IQ3 = IQ + 2*N_SLCF_MAX
            OPEN(LU_SLCF(IQ3,NM),FILE=FN_SLCF(IQ3,NM),FORM='UNFORMATTED',STATUS='OLD',POSITION='APPEND')
            NX = I2 + 1 - I1
            NY = J2 + 1 - J1
            NZ = K2 + 1 - K1
            IF (NX*NY*NZ>0) THEN
               ALLOCATE(QQ_PACK(NX*NY*NZ))

               DO K = K1, K2
                  KFACT = (K-K1)
                  DO J = J1, J2
                     JFACT = (J-J1)*NZ
                     DO I = I1, I2
                        IFACT = (I - I1)*NY*NZ
                        QQ_PACK(1+IFACT+JFACT+KFACT) = QQ(I,J,K,1)
                     ENDDO
                  ENDDO
               ENDDO

               CALL SLICE_TO_RLEFILE(LU_SLCF(IQ3,NM), STIME, NX, NY, NZ, QQ_PACK, SL%RLE_MIN, SL%RLE_MAX)
               DEALLOCATE(QQ_PACK)
            ENDIF
            CLOSE(LU_SLCF(IQ3,NM))
         ENDIF

         IF (.NOT.SL%DEBUG) THEN
            IF (CC_CELL_CENTERED) THEN
               SLICE_MIN = QQ(MIN(I1+1,I2),MIN(J1+1,J2),MIN(K1+1,K2),1)
               SLICE_MAX = SLICE_MIN
               DO K = MIN(K1+1,K2), K2
                  DO J = MIN(J1+1,J2), J2
                     DO I = MIN(I1+1,I2), I2
                        SLICE_MIN = MIN(SLICE_MIN,QQ(I,J,K,1))
                        SLICE_MAX = MAX(SLICE_MAX,QQ(I,J,K,1))
                     ENDDO
                  ENDDO
               ENDDO
            ELSE
               SLICE_MIN = QQ(I1,J1,K1,1)
               SLICE_MAX = SLICE_MIN
               DO K = K1, K2
                  DO J = J1, J2
                     DO I = I1, I2
                        SLICE_MIN = MIN(SLICE_MIN,QQ(I,J,K,1))
                        SLICE_MAX = MAX(SLICE_MAX,QQ(I,J,K,1))
                     ENDDO
                  ENDDO
               ENDDO
            ENDIF
         ENDIF

         IQ2 = IQ + N_SLCF_MAX
         OPEN(LU_SLCF(IQ2,NM),FILE=FN_SLCF(IQ2,NM),FORM='FORMATTED',STATUS='OLD',POSITION='APPEND')
         WRITE(LU_SLCF(IQ2,NM),'(ES13.6,1X,ES13.6,1X,ES13.6)') STIME, SLICE_MIN, SLICE_MAX
         CLOSE(LU_SLCF(IQ2,NM))
      ELSE
         STIME = REAL(T_BEGIN + (T-T_BEGIN)*TIME_SHRINK_FACTOR,FB)
         ! write geometry for slice file
         IF (ABS(STIME-T_BEGIN)<TWO_EPSILON_EB) THEN
            ! geometry and data file at first time step
            OPEN(LU_SLCF_GEOM(IQ,NM),FILE=FN_SLCF_GEOM(IQ,NM),FORM='UNFORMATTED',STATUS='REPLACE')
            CALL DUMP_SLICE_GEOM(LU_SLCF_GEOM(IQ,NM),SL%SLICETYPE,1,STIME,I1,I2,J1,J2,K1,K2)
            CLOSE(LU_SLCF_GEOM(IQ,NM))

            OPEN(LU_SLCF(IQ,NM),FILE=FN_SLCF(IQ,NM),FORM='UNFORMATTED',STATUS='REPLACE')
            OPEN(LU_SLCF(IQ+N_SLCF_MAX,NM),FILE=FN_SLCF(IQ+N_SLCF_MAX,NM),FORM='FORMATTED',STATUS='REPLACE')
            CALL DUMP_SLICE_GEOM_DATA(LU_SLCF(IQ,NM),LU_SLCF(IQ+N_SLCF_MAX,NM),CC_INTERP2FACES,SL%CELL_CENTERED,SL%SLICETYPE, &
                              1,STIME,I1,I2,J1,J2,K1,K2,0,&
                              IND,IND2,Y_INDEX,Z_INDEX,PART_INDEX,VELO_INDEX,0,PROP_INDEX,REAC_INDEX,MATL_INDEX,T,DT,NM)
         ELSE
            ! data file at subsequent time steps
            OPEN(LU_SLCF(IQ,NM),FILE=FN_SLCF(IQ,NM),FORM='UNFORMATTED',STATUS='OLD',POSITION='APPEND')
            OPEN(LU_SLCF(IQ+N_SLCF_MAX,NM),FILE=FN_SLCF(IQ+N_SLCF_MAX,NM),FORM='FORMATTED',STATUS='OLD',POSITION='APPEND')
            CALL DUMP_SLICE_GEOM_DATA(LU_SLCF(IQ,NM),LU_SLCF(IQ+N_SLCF_MAX,NM),CC_INTERP2FACES,SL%CELL_CENTERED,SL%SLICETYPE, &
                              0,STIME,I1,I2,J1,J2,K1,K2,0,&
                              IND,IND2,Y_INDEX,Z_INDEX,PART_INDEX,VELO_INDEX,0,PROP_INDEX,REAC_INDEX,MATL_INDEX,T,DT,NM)
         ENDIF
         CLOSE(LU_SLCF(IQ,NM))
         CLOSE(LU_SLCF(IQ+N_SLCF_MAX,NM))
      ENDIF
   ENDIF

ENDDO QUANTITY_LOOP

!!! AM 150923 - this is 2d output of main files 
! Write out the PLOT3D ``q'' file

IF (PLOT3D) THEN
   ZERO = 0._EB
   WRITE(LU_PL3D(NM)) IBP1,JBP1,KBP1
   WRITE(LU_PL3D(NM)) ZERO,ZERO,ZERO,ZERO
   WRITE(LU_PL3D(NM)) ((((QQ(I,J,K,IQ),I=0,IBAR),J=0,JBAR),K=0,KBAR),IQ=1,5)
   CLOSE(LU_PL3D(NM))
   DO IQ = 1, 5
      PLOT3D_MIN = QQ(0,0,0,IQ)
      PLOT3D_MAX = PLOT3D_MIN
      DO K = 0, KBAR
         DO J = 0, JBAR
            DO I = 0, IBAR
              PLOT3D_MIN = MIN(PLOT3D_MIN,QQ(I,J,K,IQ))
              PLOT3D_MAX = MAX(PLOT3D_MAX,QQ(I,J,K,IQ))
            END DO
         END DO
      END DO
      WRITE(LU_PL3D(NM+NMESHES),'(1X,E13.6,1X,E13.6)')PLOT3D_MIN,PLOT3D_MAX
   END DO
   PLOT3D_MIN = 10.0_FB**30
   PLOT3D_MAX = -PLOT3D_MIN
   DO K = 0, KBAR
      DO J = 0, JBAR
         DO I = 0, IBAR
           UVEL = QQ(I,J,K,2)
           VVEL = QQ(I,J,K,3)
           WVEL = QQ(I,J,K,4)
           VEL = SQRT(UVEL*UVEL + VVEL*VVEL + WVEL*WVEL)
           PLOT3D_MIN = MIN(PLOT3D_MIN,VEL)
           PLOT3D_MAX = MAX(PLOT3D_MAX,VEL)
         END DO
      END DO
   END DO
   WRITE(LU_PL3D(NM+NMESHES),'(1X,E13.6,1X,E13.6)')PLOT3D_MIN,PLOT3D_MAX
   CLOSE(LU_PL3D(NM+NMESHES))
ENDIF

CONTAINS


REAL(EB) FUNCTION CORNER_VALUE(A,B,S,INDX)

REAL(EB), INTENT(IN), DIMENSION(0:,0:,0:) :: A,B,S
INTEGER, INTENT(IN) :: INDX

IF (ABS(S(I,J,K))<=TWO_EPSILON_EB) THEN
   CORNER_VALUE = OUTPUT_QUANTITY(INDX)%AMBIENT_VALUE
ELSE
   CORNER_VALUE = S(I,J,K)*(A(I,J,K)    *B(I,J,K)     + A(I+1,J,K)    *B(I+1,J,K)   + &
                            A(I,J,K+1)  *B(I,J,K+1)   + A(I+1,J,K+1)  *B(I+1,J,K+1) + &
                            A(I,J+1,K)  *B(I,J+1,K)   + A(I+1,J+1,K)  *B(I+1,J+1,K) + &
                            A(I,J+1,K+1)*B(I,J+1,K+1) + A(I+1,J+1,K+1)*B(I+1,J+1,K+1))
ENDIF

END FUNCTION CORNER_VALUE


REAL(EB) FUNCTION FACE_VALUE()

REAL(EB) :: AA(0:1,0:1)
INTEGER :: IE,ICMM,ICMP,ICPM

SELECT CASE(OUTPUT_QUANTITY(IND)%IOR)
   CASE(1) ; AA(0:1,0:1) = QUANTITY(I,J:J+1,K:K+1)
   CASE(2) ; AA(0:1,0:1) = QUANTITY(I:I+1,J,K:K+1)
   CASE(3) ; AA(0:1,0:1) = QUANTITY(I:I+1,J:J+1,K)
END SELECT
ICMM = CELL_INDEX(I,J,K)
IF (ICMM>0) THEN
   SELECT CASE(IND)
      CASE(6)
         ICPM = CELL_INDEX(I,J+1,K)
         ICMP = CELL_INDEX(I,J,K+1)
         IE = CELL(ICMM)%EDGE_INDEX(8)
         IF (EDGE(IE)%U_AVG>-1.E5_EB) THEN ; AA(0,0)=EDGE(IE)%U_AVG ; AA(0,1)=EDGE(IE)%U_AVG ; ENDIF
         IE = CELL(ICMM)%EDGE_INDEX(12)
         IF (EDGE(IE)%U_AVG>-1.E5_EB) THEN ; AA(0,0)=EDGE(IE)%U_AVG ; AA(1,0)=EDGE(IE)%U_AVG ; ENDIF
         IE = CELL(ICPM)%EDGE_INDEX(8)
         IF (EDGE(IE)%U_AVG>-1.E5_EB) THEN ; AA(1,0)=EDGE(IE)%U_AVG ; AA(1,1)=EDGE(IE)%U_AVG ; ENDIF
         IE = CELL(ICMP)%EDGE_INDEX(12)
         IF (EDGE(IE)%U_AVG>-1.E5_EB) THEN ; AA(0,1)=EDGE(IE)%U_AVG ; AA(1,1)=EDGE(IE)%U_AVG ; ENDIF
      CASE(7)
         ICPM = CELL_INDEX(I+1,J,K)
         ICMP = CELL_INDEX(I,J,K+1)
         IE = CELL(ICMM)%EDGE_INDEX(4)
         IF (EDGE(IE)%V_AVG>-1.E5_EB) THEN ; AA(0,0)=EDGE(IE)%V_AVG ; AA(0,1)=EDGE(IE)%V_AVG ; ENDIF
         IE = CELL(ICMM)%EDGE_INDEX(12)
         IF (EDGE(IE)%V_AVG>-1.E5_EB) THEN ; AA(0,0)=EDGE(IE)%V_AVG ; AA(1,0)=EDGE(IE)%V_AVG ; ENDIF
         IE = CELL(ICPM)%EDGE_INDEX(4)
         IF (EDGE(IE)%V_AVG>-1.E5_EB) THEN ; AA(1,0)=EDGE(IE)%V_AVG ; AA(1,1)=EDGE(IE)%V_AVG ; ENDIF
         IE = CELL(ICMP)%EDGE_INDEX(12)
         IF (EDGE(IE)%V_AVG>-1.E5_EB) THEN ; AA(0,1)=EDGE(IE)%V_AVG ; AA(1,1)=EDGE(IE)%V_AVG ; ENDIF
      CASE(8)
         ICPM = CELL_INDEX(I+1,J,K)
         ICMP = CELL_INDEX(I,J+1,K)
         IE = CELL(ICMM)%EDGE_INDEX(4)
         IF (EDGE(IE)%W_AVG>-1.E5_EB) THEN ; AA(0,0)=EDGE(IE)%W_AVG ; AA(0,1)=EDGE(IE)%W_AVG ; ENDIF
         IE = CELL(ICMM)%EDGE_INDEX(8)
         IF (EDGE(IE)%W_AVG>-1.E5_EB) THEN ; AA(0,0)=EDGE(IE)%W_AVG ; AA(1,0)=EDGE(IE)%W_AVG ; ENDIF
         IE = CELL(ICPM)%EDGE_INDEX(4)
         IF (EDGE(IE)%W_AVG>-1.E5_EB) THEN ; AA(1,0)=EDGE(IE)%W_AVG ; AA(1,1)=EDGE(IE)%W_AVG ; ENDIF
         IE = CELL(ICMP)%EDGE_INDEX(8)
         IF (EDGE(IE)%W_AVG>-1.E5_EB) THEN ; AA(0,1)=EDGE(IE)%W_AVG ; AA(1,1)=EDGE(IE)%W_AVG ; ENDIF
   END SELECT
ENDIF

FACE_VALUE = 0.25_EB*SUM(AA)

END FUNCTION FACE_VALUE


REAL(EB) FUNCTION EDGE_VALUE(A,S,INDX)

REAL(EB), INTENT(IN), DIMENSION(0:,0:,0:) :: A,S
INTEGER, INTENT(IN) :: INDX

IF (ABS(S(I,J,K))<=TWO_EPSILON_EB) THEN
   EDGE_VALUE = OUTPUT_QUANTITY(INDX)%AMBIENT_VALUE
ELSE
   EDGE_VALUE = A(I,J,K)
ENDIF

END FUNCTION EDGE_VALUE

END SUBROUTINE DUMP_SLCF









!> \brief Record HRR, etc, in the file CHID_hrr.csv
!> \param T Current simulation time (s)
!> \param DT Current time step size (s)

SUBROUTINE DUMP_HRR(T,DT)

REAL(EB), INTENT(IN) :: T,DT
REAL(FB) :: STIME
INTEGER :: NM,I,N_ZONE_TMP
REAL(EB) :: Q_DOT_TOTAL(N_Q_DOT),M_DOT_TOTAL(N_TRACKED_SPECIES)
REAL(EB), DIMENSION(:), ALLOCATABLE ::  P_ZONE_P

STIME = REAL(T_BEGIN + (T-T_BEGIN)*TIME_SHRINK_FACTOR,FB)
Q_DOT_TOTAL = 0._EB
M_DOT_TOTAL = 0._EB

DO NM=1,NMESHES
   Q_DOT_TOTAL(:) = Q_DOT_TOTAL(:) + Q_DOT_SUM(:,NM)/MAX(DT,T-T_LAST_DUMP_HRR)
   M_DOT_TOTAL(:) = M_DOT_TOTAL(:) + M_DOT_SUM(:,NM)/MAX(DT,T-T_LAST_DUMP_HRR)
ENDDO

N_ZONE_TMP = 0
IF (N_ZONE>0) THEN
   ALLOCATE(P_ZONE_P(N_ZONE))
   DO I=1,N_ZONE
      N_ZONE_TMP = N_ZONE_TMP + 1
      P_ZONE_P(N_ZONE_TMP) = MESHES(1)%PBAR(1,I) - P_INF
   ENDDO
ENDIF

WRITE(TCFORM,'(A,I0,5A)') "(",9+N_TRACKED_SPECIES+N_ZONE_TMP,"(",FMT_R,",','),",FMT_R,")"
IF (N_ZONE_TMP>0) THEN
   WRITE(LU_HRR,TCFORM) STIME,0.001_EB*Q_DOT_TOTAL(1:N_Q_DOT),0.001_EB*SUM(Q_DOT_TOTAL(1:N_Q_DOT-1)),&
                        M_DOT_TOTAL(1:N_TRACKED_SPECIES),(P_ZONE_P(I),I=1,N_ZONE_TMP)
ELSE
   WRITE(LU_HRR,TCFORM) STIME,0.001_EB*Q_DOT_TOTAL(1:N_Q_DOT),0.001_EB*SUM(Q_DOT_TOTAL(1:N_Q_DOT-1)),&
                        M_DOT_TOTAL(1:N_TRACKED_SPECIES)
ENDIF

IF (N_ZONE>0) DEALLOCATE(P_ZONE_P)

END SUBROUTINE DUMP_HRR






INCLUDE 'dump_no_output.f90'
INCLUDE 'dump_other_output.f90'
END MODULE DUMP
